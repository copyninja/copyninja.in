<!DOCTYPE html><html lang="en"><head><link href="https://fonts.googleapis.com/css?family=Cantarell" rel="stylesheet"><title>Working around type system of Go with unsafe</title><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="https://copyninja.in/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Random Ramblings Full Atom Feed"><link href="https://copyninja.in/feeds/{slug}.atom.xml" type="application/atom+xml" rel="alternate" title="Random Ramblings Categories Atom Feed"><link rel="stylesheet" type="text/css" href="/theme/css/pygments.css"><link rel="stylesheet" type="text/css" href="/theme/css/default.css"><meta name="tags" content="golang"><meta name="tags" content="go"><meta name="tags" content="programming"></head><body><div id="header" class="body"><div id="navigation"> | <a href="https://copyninja.in">Home</a> | | <a href="https://copyninja.in/about">About</a> | | <a href="https://copyninja.in/contact">Contact</a> | | <a href="https://copyninja.in/categories.html">Categories</a> | | <a href="https://copyninja.in/tags.html">Tags</a> | </div><h1><a href="https://copyninja.in/blog/workaround-gotypesystems.html">Working around type system of Go with unsafe</a></h1></div><div id="content"><section id="content" class="body"><footer class="post-info"><p> Posted on Mar 12, 2014 By copyninja under development </p></abbr></footer><div class="entry-content"><p>Go language has a strong type system unlike C, and some times this will be head ache when we want to interact with C data types with Cgo or just to convert a Go type to lets say byte slice. I recently faced the same problem and after poking around things, I learned the Go provides <em>unsafe</em> package which can be used to work around the Go's type system.</p><div class="section" id="problem"><h2>Problem</h2><p>Recently I started using <em>Cgo</em> to use some C library I had to write some tools for development and testing. The reason I chose <em>Go</em> for this was prototyping and writing some quick tools is much easier in Go than done in C.</p><p>The C library had some function which takes pointer to array types and fills it with some values. The problem I was facing here was how to create a C array in Go. Go does have array but its largely used as internal representation for much efficient type called <em>slice</em> and I can't directly cast a byte slice into an C array.</p><p>Second problem I had was I had to store arbitrary Go types like float (float32,float64) and int (int32, int64) etc. into C array.</p><p>So in brief, the problems that needed to solve are</p><ol class="arabic simple"><li>Find a way to convert byte slice from Go into C array and vice versa.</li><li>Find a way to convert and store Go types into a C array.</li></ol></div><div class="section" id="solution"><h2>Solution</h2><p>Basically C array are sequence of memory location which can be statically or dynamically allocated. In <em>Cgo</em> its possible to access C standard library functions for memory allocation, so why not use it. The memory allocation function then returns the pointer to starting of allocated memory, we can use this pointer to write Go's bytes into the memory location and bytes from memory location into Go's slice.</p><p>The pointer returned by C allocation functions are not directly usable for memory dereferencing in Go, here is where <em>unsafe</em> package kicks in. We will cast the return of C allocation function as <em>unsafe.Pointer</em> type and from the documentation of unsafe package,</p><blockquote><ol class="arabic simple"><li>A pointer value of any type can be converted to a Pointer.</li><li>A Pointer can be converted to a pointer value of any type.</li><li>A uintptr can be converted to a Pointer.</li><li>A Pointer can be converted to a uintptr.</li></ol></blockquote><p>So we can then cast unsafe.Pointer to <em>uintptr</em> which is the Go type which is large enough to hold any memory address in Go and can be used for pointer arithmetic just like we do in C (of course with some more castings).</p><p>Below I'm pasting a simplified code in C which I wrote for this post.</p><div class="highlight"><pre><span></span><span class="cp">#ifndef __BYTETEST_H__</span>
<span class="cp">#define __BYTETEST_H__</span>

<span class="k">typedef</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">UBYTE</span><span class="p">;</span>

<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">ArrayReadFunc</span><span class="p">(</span><span class="n">UBYTE</span><span class="w"> </span><span class="o">*</span><span class="n">arrayout</span><span class="p">);</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">ArrayWriteFunc</span><span class="p">(</span><span class="n">UBYTE</span><span class="w"> </span><span class="o">*</span><span class="n">arrayin</span><span class="p">);</span>

<span class="cp">#endif</span>
</pre></div><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;bytetest.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">ArrayReadFunc</span><span class="p">(</span><span class="n">UBYTE</span><span class="w"> </span><span class="o">*</span><span class="n">arrayout</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">     </span><span class="n">UBYTE</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span>
<span class="w">                        </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">17</span><span class="p">,</span>
<span class="w">                        </span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="mi">19</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">};</span>
<span class="w">     </span><span class="n">memcpy</span><span class="p">(</span><span class="n">arrayout</span><span class="p">,</span><span class="w"> </span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">ArrayWriteFunc</span><span class="p">(</span><span class="n">UBYTE</span><span class="w"> </span><span class="o">*</span><span class="n">arrayin</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">     </span><span class="n">UBYTE</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>

<span class="w">     </span><span class="n">memcpy</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="n">arrayin</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">);</span>

<span class="w">     </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Byte slice array received from Go:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">     </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">++</span><span class="p">){</span>
<span class="w">             </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">     </span><span class="p">}</span>

<span class="w">     </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div><p>Functions are written just for this post and they don't really do anything. As you can see <cite>ArrayReadFunc</cite> takes a pointer to array and fills it with content of another array using <cite>memcpy</cite>. Function <cite>ArrayWriteFunc</cite> on other hand takes pointer to array and copies its content to internal array. I've added print logic to <cite>ArrayWriteFunc</cite> just to show that values passed from <em>Go</em> are making it here.</p><p>Below is the Go code which uses the above C files passes byte slice to get value out of C code and array made of byte slice to C function to send values in.</p><div class="highlight"><pre><span></span><span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="cm">/*</span>
<span class="cm">#cgo CFLAGS: -std=c99</span>

<span class="cm">#include &quot;bytetest.h&quot;</span>
<span class="cm">#include &lt;stdlib.h&gt;</span>
<span class="cm">*/</span>
<span class="kn">import</span><span class="w"> </span><span class="s">&quot;C&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">     </span><span class="s">&quot;fmt&quot;</span>
<span class="w">     </span><span class="s">&quot;unsafe&quot;</span>
<span class="p">)</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">ReadArray</span><span class="p">()</span><span class="w"> </span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="w"> </span><span class="p">{</span>
<span class="w">       </span><span class="kd">var</span><span class="w"> </span><span class="nx">outArray</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="w"> </span><span class="p">(</span><span class="nx">C</span><span class="p">.</span><span class="nx">calloc</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="w">       </span><span class="nx">C</span><span class="p">.</span><span class="nx">ArrayReadFunc</span><span class="p">((</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">UBYTE</span><span class="p">)(</span><span class="nx">outArray</span><span class="p">))</span>

<span class="w">       </span><span class="k">return</span><span class="w"> </span><span class="nx">outArray</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">WriteArray</span><span class="p">(</span><span class="nx">inArray</span><span class="w"> </span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">       </span><span class="nx">C</span><span class="p">.</span><span class="nx">ArrayWriteFunc</span><span class="p">((</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">UBYTE</span><span class="p">)(</span><span class="nx">inArray</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">CArrayToByteSlice</span><span class="p">(</span><span class="nx">array</span><span class="w"> </span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span><span class="w"> </span><span class="nx">size</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="w"> </span><span class="p">{</span>
<span class="w">       </span><span class="kd">var</span><span class="w"> </span><span class="nx">arrayptr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span>
<span class="w">       </span><span class="kd">var</span><span class="w"> </span><span class="nx">byteSlice</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span><span class="w"> </span><span class="nx">size</span><span class="p">)</span>

<span class="w">       </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">byteSlice</span><span class="p">);</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">               </span><span class="nx">byteSlice</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">byte</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">UBYTE</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="nx">arrayptr</span><span class="p">)))</span>
<span class="w">               </span><span class="nx">arrayptr</span><span class="w"> </span><span class="o">++</span>
<span class="w">       </span><span class="p">}</span>

<span class="w">       </span><span class="k">return</span><span class="w"> </span><span class="nx">byteSlice</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">ByteSliceToCArray</span><span class="w"> </span><span class="p">(</span><span class="nx">byteSlice</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">)</span><span class="w"> </span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="w"> </span><span class="p">{</span>
<span class="w">       </span><span class="kd">var</span><span class="w"> </span><span class="nx">array</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="nx">C</span><span class="p">.</span><span class="nx">calloc</span><span class="p">(</span><span class="nx">C</span><span class="p">.</span><span class="nx">size_t</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">byteSlice</span><span class="p">)),</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>
<span class="w">       </span><span class="kd">var</span><span class="w"> </span><span class="nx">arrayptr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span>

<span class="w">       </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">byteSlice</span><span class="p">);</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">UBYTE</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="nx">arrayptr</span><span class="p">))</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">C</span><span class="p">.</span><span class="nx">UBYTE</span><span class="p">(</span><span class="nx">byteSlice</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
<span class="w">              </span><span class="nx">arrayptr</span><span class="w"> </span><span class="o">++</span>
<span class="w">       </span><span class="p">}</span>

<span class="w">       </span><span class="k">return</span><span class="w"> </span><span class="nx">array</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">(){</span>
<span class="w">        </span><span class="nx">carray</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ReadArray</span><span class="p">()</span>
<span class="w">        </span><span class="k">defer</span><span class="w"> </span><span class="nx">C</span><span class="p">.</span><span class="nx">free</span><span class="p">(</span><span class="nx">carray</span><span class="p">)</span>

<span class="w">        </span><span class="nx">carraybytes</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">CArrayToByteSlice</span><span class="p">(</span><span class="nx">carray</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span>

<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;C array converted to byte slice:&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">carraybytes</span><span class="p">);</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">carraybytes</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">()</span>

<span class="w">        </span><span class="nx">gobytes</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">{</span><span class="mi">21</span><span class="p">,</span><span class="w"> </span><span class="mi">22</span><span class="p">,</span><span class="w"> </span><span class="mi">23</span><span class="p">,</span><span class="w"> </span><span class="mi">24</span><span class="p">,</span><span class="w"> </span><span class="mi">25</span><span class="p">,</span><span class="w"> </span><span class="mi">26</span><span class="p">,</span><span class="w"> </span><span class="mi">27</span><span class="p">,</span><span class="w"> </span><span class="mi">28</span><span class="p">,</span><span class="w"> </span><span class="mi">29</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">,</span>
<span class="w">                </span><span class="mi">31</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="mi">33</span><span class="p">,</span><span class="w"> </span><span class="mi">34</span><span class="p">,</span><span class="w"> </span><span class="mi">35</span><span class="p">,</span><span class="w"> </span><span class="mi">36</span><span class="p">,</span><span class="w"> </span><span class="mi">37</span><span class="p">,</span><span class="w"> </span><span class="mi">38</span><span class="p">,</span><span class="w"> </span><span class="mi">39</span><span class="p">,</span><span class="w"> </span><span class="mi">40</span><span class="p">}</span>
<span class="w">        </span><span class="nx">gobytesarray</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ByteSliceToCArray</span><span class="p">(</span><span class="nx">gobytes</span><span class="p">)</span>
<span class="w">        </span><span class="k">defer</span><span class="w"> </span><span class="nx">C</span><span class="p">.</span><span class="nx">free</span><span class="p">(</span><span class="nx">gobytesarray</span><span class="p">)</span>

<span class="w">        </span><span class="nx">WriteArray</span><span class="p">(</span><span class="nx">gobytesarray</span><span class="p">)</span>
<span class="p">}</span>
</pre></div><p>Functions <cite>ReadArray</cite> and <cite>WriteArray</cite> are just wrapper to the calls to C counter parts <cite>ArrayReadFunc</cite> and <cite>ArrayWriteFunc</cite>. <cite>ReadArray</cite> returns <cite>unsafe.Pointer</cite> which is allocated C array and should be freed by caller. <cite>WriteArray</cite> takes <cite>unsafe.Pointer</cite> which is pointing to memory location containing C array.</p><p>Now the functions of interest are <cite>CArrayToByteSlice</cite> and <cite>ByteSliceToCArray</cite>. It should be pretty clear from the above code to understand what is happening in these functions. Still I will just put explain them briefly.</p><p><cite>ByteSliceToCArray</cite> allocates a C array using <cite>calloc</cite> from C standard library. It then creates a <cite>uintptr</cite>, a pointer type in Go which is used to dereference the each memory location and store bytes from the input byte slice in them.</p><p><cite>CArrayToByteSlice</cite> on other hands creates a <cite>uintptr</cite> type by casting input unsafe.Pointer type and then uses this pointer type to dereference values from memoy and store it in byte slice with suitable casting.</p><p>So lets build the code and run it and see the output:</p><pre class="literal-block">
C array converted to byte slice:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
Byte slice array received from Go:
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40
</pre><p>So yes it actually works and values are moving across C and Go. This solves first problem in hand next is converting arbitrary Go types into byte slices.</p><p>There are many cases where we would like to convert an arbitrary Go types like (int, float) into bytes. One such use case I found was when writing a TCP client for communicating with a Server written using C speaking custom protocol. Here I'm just going to show how to convert types like float, int to byte slice, I've not tried converting structures but it is certainly possible.</p><p>Below is the function which can convert int32,float32 into byte slice it can also be extended for other types.</p><div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">CopyValueToByte</span><span class="p">(</span><span class="nx">value</span><span class="w"> </span><span class="kd">interface</span><span class="p">{})</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="kd">var</span><span class="w"> </span><span class="nx">valptr</span><span class="w"> </span><span class="kt">uintptr</span>
<span class="w">     </span><span class="kd">var</span><span class="w"> </span><span class="nx">slice</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span>

<span class="w">     </span><span class="k">switch</span><span class="w"> </span><span class="nx">t</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">value</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="k">case</span><span class="w"> </span><span class="kt">int32</span><span class="p">:</span>
<span class="w">             </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">value</span><span class="p">.(</span><span class="kt">int32</span><span class="p">)</span>
<span class="w">             </span><span class="nx">valptr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">i</span><span class="p">))</span>
<span class="w">             </span><span class="nx">slice</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span><span class="w"> </span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Sizeof</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
<span class="w">     </span><span class="k">case</span><span class="w"> </span><span class="kt">float32</span><span class="p">:</span>
<span class="w">             </span><span class="nx">f</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">value</span><span class="p">.(</span><span class="kt">float32</span><span class="p">)</span>
<span class="w">             </span><span class="nx">valptr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">f</span><span class="p">))</span>
<span class="w">             </span><span class="nx">slice</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span><span class="w"> </span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Sizeof</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span>
<span class="w">     </span><span class="k">default</span><span class="p">:</span>
<span class="w">             </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span><span class="s">&quot;Unsupported type: %T\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">t</span><span class="p">)</span>
<span class="w">             </span><span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">     </span><span class="p">}</span>

<span class="w">     </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">);</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">             </span><span class="nx">slice</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">byte</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="nx">valptr</span><span class="p">)))</span>
<span class="w">             </span><span class="nx">valptr</span><span class="o">++</span>
<span class="w">     </span><span class="p">}</span>

<span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="nx">slice</span>
<span class="p">}</span>
</pre></div><p>This function is generic which can take various types of value. First we will use Go's type assertion to determine the type and creates a <cite>uintptr</cite> pointer for the value and allocates byte slice depending on the size of the value as calculated using <cite>unsafe.Sizeof</cite>. Later it uses the pointer to dereference value from memory location and copies each byte into byte slice. <em>The idea used here is every type is represented as certain number of bytes in the memory.</em> Below is the entire program.</p><div class="highlight"><pre><span></span><span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">     </span><span class="s">&quot;fmt&quot;</span>
<span class="w">     </span><span class="s">&quot;unsafe&quot;</span>
<span class="w">     </span><span class="s">&quot;os&quot;</span>
<span class="p">)</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">CopyValueToByte</span><span class="p">(</span><span class="nx">value</span><span class="w"> </span><span class="kd">interface</span><span class="p">{})</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="kd">var</span><span class="w"> </span><span class="nx">valptr</span><span class="w"> </span><span class="kt">uintptr</span>
<span class="w">     </span><span class="kd">var</span><span class="w"> </span><span class="nx">slice</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span>

<span class="w">     </span><span class="k">switch</span><span class="w"> </span><span class="nx">t</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">value</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="k">case</span><span class="w"> </span><span class="kt">int32</span><span class="p">:</span>
<span class="w">             </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">value</span><span class="p">.(</span><span class="kt">int32</span><span class="p">)</span>
<span class="w">             </span><span class="nx">valptr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">i</span><span class="p">))</span>
<span class="w">             </span><span class="nx">slice</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span><span class="w"> </span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Sizeof</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
<span class="w">     </span><span class="k">case</span><span class="w"> </span><span class="kt">float32</span><span class="p">:</span>
<span class="w">             </span><span class="nx">f</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">value</span><span class="p">.(</span><span class="kt">float32</span><span class="p">)</span>
<span class="w">             </span><span class="nx">valptr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">f</span><span class="p">))</span>
<span class="w">             </span><span class="nx">slice</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span><span class="w"> </span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Sizeof</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span>
<span class="w">     </span><span class="k">default</span><span class="p">:</span>
<span class="w">             </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span><span class="s">&quot;Unsupported type: %T\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">t</span><span class="p">)</span>
<span class="w">             </span><span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">     </span><span class="p">}</span>

<span class="w">     </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">);</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">             </span><span class="nx">slice</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">byte</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="nx">valptr</span><span class="p">)))</span>
<span class="w">             </span><span class="nx">valptr</span><span class="o">++</span>
<span class="w">     </span><span class="p">}</span>

<span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="nx">slice</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="nx">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">float32</span><span class="p">(</span><span class="o">-</span><span class="mf">10.3</span><span class="p">)</span>

<span class="w">     </span><span class="nx">floatbytes</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">CopyValueToByte</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>

<span class="w">     </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Float value as byte slice:&quot;</span><span class="p">)</span>
<span class="w">     </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">floatbytes</span><span class="p">);</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">             </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%x &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">floatbytes</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
<span class="w">     </span><span class="p">}</span>

<span class="w">     </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">()</span>

<span class="w">     </span><span class="nx">b</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">new</span><span class="p">(</span><span class="kt">float32</span><span class="p">)</span>
<span class="w">     </span><span class="nx">bptr</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>

<span class="w">     </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">floatbytes</span><span class="p">);</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">             </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="nx">bptr</span><span class="p">))</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">floatbytes</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="w">             </span><span class="nx">bptr</span><span class="o">++</span>
<span class="w">     </span><span class="p">}</span>

<span class="w">     </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Byte value copied to float var: %f\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="nx">b</span><span class="p">)</span>

<span class="p">}</span>
</pre></div><p>The above conversion can also be achieved using <cite>encoding/binary</cite> package provided by Go. But <a class="reference external" href="https://twitter.com/dgryski/status/441514574307921920">its been told to me</a> that it makes things pretty slow.</p></div><div class="section" id="conclusion"><h2>Conclusion</h2><p>So goes <cite>unsafe.Pointer</cite> is really powerful thing which allows us to work around the Go's type system but as package documentation says <strong>it should be used with care</strong></p><blockquote> PS: I'm not really sure if its recommended to use allocation functions from C standard library, I will wait for expert gophers to comment on that.</blockquote></div></div><div id="footer"><p><italic>Tagged as: go, golang, programming, </italic></p></section></div><hr><div id="footer"> Site Proudly powered by <a href="http://getpelican.com/">Pelican</a></div></body></html>