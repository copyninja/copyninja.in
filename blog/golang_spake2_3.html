<!DOCTYPE html>
<html lang="en"><head><link href="https://fonts.googleapis.com/css?family=Cantarell" rel="stylesheet"/><title>SPAKE2 In Golang: Finite fields of Elliptic Curve</title><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><meta content="width=device-width, initial-scale=1" name="viewport"/><link href="https://copyninja.in/feeds/all.atom.xml" rel="alternate" title="Random Ramblings Full Atom Feed" type="application/atom+xml"/><link href="https://copyninja.in/feeds/{slug}.atom.xml" rel="alternate" title="Random Ramblings Categories Atom Feed" type="application/atom+xml"/><link href="/theme/css/pygments.css" rel="stylesheet" type="text/css"/><link href="/theme/css/default.css" rel="stylesheet" type="text/css"/><meta content="go" name="tags"/><meta content="golang" name="tags"/><meta content="spake2" name="tags"/><meta content="cryptography" name="tags"/><meta content="ecc" name="tags"/></head><body><div class="body" id="header"><div id="navigation"> | <a href="https://copyninja.in">Home</a> | | <a href="https://copyninja.in/about">About</a> | | <a href="https://copyninja.in/contact">Contact</a> | | <a href="https://copyninja.in/categories.html">Categories</a> | | <a href="https://copyninja.in/tags.html">Tags</a> | </div><h1><a href="https://copyninja.in/blog/golang_spake2_3.html">SPAKE2 In Golang: Finite fields of Elliptic Curve</a></h1></div><div id="content"><section class="body" id="content"><footer class="post-info"><p> Posted on Aug 12, 2018 By copyninja under development </p></footer><div class="entry-content"><p>In my <a class="reference external" href="https://copyninja.info/blog/golang_spake2_2.html">previous post</a> I talked about elliptic curve basics and how the operations are done on elliptic curves, including the algebraic representation which is needed for computers. For usage in cryptography we need a elliptic curve group with some specified number of elements, that is what we called <strong>Finite Fields</strong>. We limit Elliptic Curve groups with some big prime number <cite>p</cite>. In this post I will try to briefly explain <em>finite fields over elliptic curve</em>.</p><div class="section" id="finite-fields"><h2>Finite Fields</h2><p><em>Finite field</em> or also called <em>Galois Field</em> is a set with finite number of elements. An example we can give is <em>integer modulo `p`</em> where <cite>p</cite> is prime. Finite fields can be denoted as <span class="math">\(\mathbb Z/p, GF(p)\)</span> or <span class="math">\(\mathbb F_p\)</span>.</p><p>Finite fields will have 2 operations addition and multiplications. These operations are closed, associative and commutative. There exists a unique identity element and inverse element for every element in the set.</p><p>Division operation in finite fields is defined as <span class="math">\(x / y = x \cdot y^{-1}\)</span>, that is x multiplied by inverse of y. and substraction <span class="math">\(x - y\)</span> is defined in terms of addition as <span class="math">\(x + (-y)\)</span> which is x added by negation of y. Multiplicative inverse can be <em>easily</em> calculated using <a class="reference external" href="http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm">extended Euclidean algorithm</a> which I've not understood yet myself as there were readily available library functions which does this for us. But I hear from Ramakrishnan that its very easy one.</p><div class="section" id="elliptic-curve-in-mathbb-f-p"><h3>Elliptic Curve in <span class="math">\(\mathbb F_p\)</span></h3><p>Now we understood what is finite fields we now need to restrict our elliptic curves to the finite field. So our original definition of elliptic curve becomes slightly different, that is we will have <cite>modulo p</cite> to restrict the elements.</p><div class="math"> \begin{equation*} \begin{array}{rcl} \left\{(x, y) \in (\mathbb{F}_p)^2 \right. &amp; \left. | \right. &amp; \left. y^2 \equiv x^3 + ax + b \pmod{p}, \right. \\ &amp; &amp; \left. 4a^3 + 27b^2 \not\equiv 0 \pmod{p}\right\}\ \cup\ \left\{0\right\} \end{array} \end{equation*} </div><p>All our previous operations can now be written as follows</p><div class="math"> \begin{equation*} \begin{array}{rcl} x_R &amp; = &amp; (m^2 - x_P - x_Q) \bmod{p} \\ y_R &amp; = &amp; [y_P + m(x_R - x_P)] \bmod{p} \\ &amp; = &amp; [y_Q + m(x_R - x_Q)] \bmod{p} \end{array} \end{equation*} </div><p>Where slope, when <span class="math">\(P \neq Q\)</span></p><div class="math"> \begin{equation*} m = (y_P - y_Q)(x_P - x_Q)^{-1} \bmod{p} \end{equation*} </div><p>and when <span class="math">\(P = Q\)</span></p><div class="math"> \begin{equation*} m = (3 x_P^2 + a)(2 y_P)^{-1} \bmod{p} \end{equation*} </div><p>So now we need to know <em>order</em> of this finite field. <em>Order</em> of elliptic curve finite field can be defined as <strong>number of points in the finite field</strong>. Unlike <em>integer modulo p</em> where number of elements are <em>0 to p-1</em>, in case of elliptic curve you need to count points from <cite>x</cite> to <cite>p-1</cite>. This counting will be <span class="math">\(O(p)\)</span>. Given large <cite>p</cite> this will be <em>hard</em> problem. But there are faster algorithm to count order of group, which even I don't know much in detail :). But from my reference its called <a class="reference external" href="https://en.wikipedia.org/wiki/Schoof%27s_algorithm">Schoof's algorithm</a>.</p></div><div class="section" id="scalar-multiplication-and-cyclic-group"><h3>Scalar Multiplication and Cyclic Group</h3><p>When we consider scalar multiplication over elliptic curve finite fields, we discover a special property. Taking example from <a class="reference external" href="http://andrea.corbellini.name/2015/05/23/elliptic-curve-cryptography-finite-fields-and-discrete-logarithms/">Andrea Corbellini's post</a>, consider curve <span class="math">\(y^2 \equiv x^3 + 2x + 3 ( mod 97)\)</span> and point <span class="math">\(P = (3,6)\)</span>. If we try calculating multiples of <cite>P</cite></p><div class="math"> \begin{align*} 0P = 0 \\ 1P = (3,6) \\ 2P = (80,10) \\ 3P = (80,87) \\ 4P = (3, 91) \\ 5P = 0 \\ 6P = (3,6) \\ 7P = (80, 10) \\ 8P = (80, 87) \\ 9P = (3, 91) \\ ... \end{align*} </div><p>If you are wondering how to calculate above (I did at first). You need to use point addition formula from earlier post where <cite>P = Q</cite> with <cite>mod 97</cite>. So we observe that there are only 5 multiples of P and they are repeating cyclicly. we can write above points as</p><ul class="simple"><li><span class="math">\(5kP = 0P\)</span></li><li><span class="math">\((5k + 1)P = 1P\)</span></li><li><span class="math">\((5k + 2)P = 2P\)</span></li><li><span class="math">\((5k + 3)P = 3P\)</span></li><li><span class="math">\((5k + 4)P = 4P\)</span></li></ul><p>Or simply we can write these as <span class="math">\(kP = (k mod 5)P\)</span>. We also note that all these 5 Points are closed under addition. This means <strong>adding two multiples of P, we obtain a multiple of P and the set of multiples of P form cyclic subgroup</strong></p><div class="math"> \begin{equation*} nP + mP = \underbrace{P + \cdots + P}_{n\ \text{times}} + \underbrace{P + \cdots + P}_{m\ \text{times}} = (n + m)P \end{equation*} </div><p>Cyclic subgroups are foundation of Elliptic Curve Cryptography (ECC).</p></div><div class="section" id="subgroup-order"><h3>Subgroup Order</h3><p>Subgroup order tells how many points are really there in the subgroup. We can redefine the <em>order of group</em> in subgroup context as <strong>order of P is the smallest positive integer such that nP = 0</strong>. In above case if you see we have smallest <cite>n</cite> as <cite>5</cite> since <cite>5P = 0</cite>. So order of subgroup above is 5, it contains 5 element.</p><p>Order of subgroup is linked to order of elliptic curve by <a class="reference external" href="https://en.wikipedia.org/wiki/Lagrange%27s_theorem_(group_theory)">Lagrange's Theorem</a> which says <strong>the order of subgroup is divisor of order of parent group</strong>. Lagrange is another name which I had read in my college, but the algorithms were different.</p><p>From this we have following steps to find out the order of subgroup with base point <cite>P</cite></p><ol class="arabic simple"><li>Calculate the elliptic curve's order <cite>N</cite> using Schoof's algorithm.</li><li>Find out all divisors of <cite>N</cite>.</li><li>For every divisor of <cite>n</cite>, compute <cite>nP</cite>.</li><li>The smallest <cite>n</cite> such that <cite>nP = 0</cite> is the order of subgroup <cite>N</cite>.</li></ol><p>Note that its important to choose smallest divisor, not a random one. In above examples 5P, 10P, 15P all satisfy condition but order of subgroup is 5.</p></div><div class="section" id="finding-base-point"><h3>Finding Base Point</h3><p>Far all above which is used in ECC, i.e. Group, subgroup and order we need a base point <cite>P</cite> to work with. So base point calculation is not done at the beginning but in the end i.e. first choose a order which looks good then look for subgroup order and finally find the suitable base point.</p><p>We learnt above that subgroup order is divisor of group order which is derived from <em>Lagrange's Theorem</em>. This term <span class="math">\(h = N/n\)</span> is actually called <strong>co-factor of the subgroup</strong>. Now why is this term co-factor important?. Without going into details, this co-factor is used to find generator for the subgroup as <span class="math">\(G = hP\)</span>.</p></div></div><div class="section" id="conclusion"><h2>Conclusion</h2><p>So now are you wondering why I went on such length to describe all these?. Well one thing I wanted to make some notes for myself because you can't find all these information in single place, another these topics we talked in my previous post and this point forms the domain parameters of <em>Elliptic Curve Cryptography</em>.</p><p>Domain parameters in ECC are the parameters which are known publicly to every one. Following are 6 parameters</p><ul class="simple"><li>Prime <cite>p</cite> which is order of Finite field</li><li>Co-efficients of curve <cite>a</cite> and <cite>b</cite></li><li>Base point <span class="math">\(\mathbb G\)</span> the generator which is the base point of curve that generates subgroup</li><li>Order of subgroup <cite>n</cite></li><li>Co-factor <cite>h</cite></li></ul><p>So in short following is the domain parameters of ECC <span class="math">\((p, a, b, G, n, h)\)</span></p><p>In my next post I will try to talk about the specific curve group which is used in SPAKE2 implementation called <strong>twisted Edwards curve</strong> and give a brief overview of SPAKE2 protocol.</p></div><script type="text/javascript">if(!document.getElementById('mathjaxscript_pelican_#%@#$@#')){var align="center",indent="0em",linebreak="false";if(false){align=(screen.width<768)?"left":align;indent=(screen.width<768)?"0em":indent;linebreak=(screen.width<768)?'true':linebreak;}
var mathjaxscript=document.createElement('script');mathjaxscript.id='mathjaxscript_pelican_#%@#$@#';mathjaxscript.type='text/javascript';mathjaxscript.src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';var configscript=document.createElement('script');configscript.type='text/x-mathjax-config';configscript[(window.opera?"innerHTML":"text")]="MathJax.Hub.Config({"+
"    config: ['MMLorHTML.js'],"+
"    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } },"+
"    jax: ['input/TeX','input/MathML','output/HTML-CSS'],"+
"    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],"+
"    displayAlign: '"+align+"',"+
"    displayIndent: '"+indent+"',"+
"    showMathMenu: true,"+
"    messageStyle: 'normal',"+
"    tex2jax: { "+
"        inlineMath: [ ['\\\\(','\\\\)'] ], "+
"        displayMath: [ ['$$','$$'] ],"+
"        processEscapes: true,"+
"        preview: 'TeX',"+
"    }, "+
"    'HTML-CSS': { "+
"        availableFonts: ['STIX', 'TeX'],"+
"        preferredFont: 'STIX',"+
"        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },"+
"        linebreaks: { automatic: "+linebreak+", width: '90% container' },"+
"    }, "+
"}); "+
"if ('default' !== 'default') {"+
"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {"+
"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;"+
"VARIANT['normal'].fonts.unshift('MathJax_default');"+
"VARIANT['bold'].fonts.unshift('MathJax_default-bold');"+
"VARIANT['italic'].fonts.unshift('MathJax_default-italic');"+
"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');"+
"});"+
"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {"+
"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;"+
"VARIANT['normal'].fonts.unshift('MathJax_default');"+
"VARIANT['bold'].fonts.unshift('MathJax_default-bold');"+
"VARIANT['italic'].fonts.unshift('MathJax_default-italic');"+
"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');"+
"});"+
"}";(document.body||document.getElementsByTagName('head')[0]).appendChild(configscript);(document.body||document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);}</script></div><div id="footer"><p><italic>Tagged as: cryptography, ecc, go, golang, spake2, </italic></p></div></section></div><hr/><div id="footer"> Site Proudly powered by <a href="http://getpelican.com/">Pelican</a></div></body></html>