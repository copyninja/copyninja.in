<!DOCTYPE html><html lang="en"><head><link href="https://fonts.googleapis.com/css?family=Cantarell" rel="stylesheet"><title>SPAKE2 in Golang: Implementing Groups</title><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="https://copyninja.in/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Random Ramblings Full Atom Feed"><link href="https://copyninja.in/feeds/{slug}.atom.xml" type="application/atom+xml" rel="alternate" title="Random Ramblings Categories Atom Feed"><link rel="stylesheet" type="text/css" href="/theme/css/pygments.css"><link rel="stylesheet" type="text/css" href="/theme/css/default.css"><meta name="tags" content="go"><meta name="tags" content="golang"><meta name="tags" content="spake2"><meta name="tags" content="cryptography"></head><body><div id="header" class="body"><div id="navigation"> | <a href="https://copyninja.in">Home</a> | | <a href="https://copyninja.in/about">About</a> | | <a href="https://copyninja.in/contact">Contact</a> | | <a href="https://copyninja.in/categories.html">Categories</a> | | <a href="https://copyninja.in/tags.html">Tags</a> | </div><h1><a href="https://copyninja.in/blog/golang_spake2_5.html">SPAKE2 in Golang: Implementing Groups</a></h1></div><div id="content"><section id="content" class="body"><footer class="post-info"><p> Posted on Sep 02, 2018 By copyninja under development </p></abbr></footer><div class="entry-content"><p>In my <a class="reference external" href="https://copyninja.info/blog/golang_spake2_4.html">previous post</a> I talked about SPAKE2 protocol and Ed25519 Curve group. This post is mostly implementation notes and decisions taken during implementing EC groups and number groups in Golang.</p><div class="section" id="in-the-beginning"><h2>In the Beginning ...</h2><p>Like always I had too many question on how to do? what to do? etc. etc. Well there is no definitive answer, you have to experiment to get the answer. So as a first step I had to decide what I need. Looking at Python implementation of SPAKE2 some basic group operations needed are as follows.</p><ul class="simple"><li>Element Addition for the group</li><li>Scalar Multiplication for the group</li><li>Scalar Multiplication with Base point/Generator of group</li></ul><p>Along with this some other functions are needed, these are not exactly group related operations, but are needed in SPAKE2 calculation. We can call them helper operations and they are listed as follows.</p><ul class="simple"><li>Convert password into Scalar of the group (Scalar is nothing but big integer in the group)</li><li>Generate a Random scalar for the group.</li><li>Constants M, N and S.</li><li>Converting group element to bytes and creating element from bytes.</li><li>Element Size for the group.</li><li>Order of the subgroup</li></ul><p>Now you might be wondering what <cite>S</cite> might be, as I only talked about <cite>M</cite> and <cite>N</cite> while explaining SPAKE2. This is for a special mode called <strong>Symmetric Mode</strong>. This special mode created by Brian Warner with help from other cryptographic folks for <strong>magic-wormhole</strong> use case. This mode removes the side/identity from the SPAKE2 protocol as we saw in previous post (A, B) and makes both side identical. This will reduce additional exchanges that had to be done to setup side/identities for both peers.</p><p>Next question was whether SPAKE2 implementation is going to be Ed25519 group specific or whether I plan to introduce other groups as well?. This was important decision I had to make, since Python version also has some integer groups I decided to make groups configurable in Golang as well with Ed25519 as default group.</p></div><div class="section" id="defining-group-interface"><h2>Defining Group Interface</h2><p>To make group as configurable in SPAKE2 package I had to define a generic type. Though Golang does not have generics, we can define <em>interface type</em> to get some flexibility. As a first try I defined <strong>Group</strong> interface as follows</p><pre class="code go literal-block">
<span class="kd">type</span><span class="w"> </span><span class="nx">Group</span><span class="w"> </span><span class="kd">interface</span><span class="w"> </span><span class="p">{</span><span class="w">
       </span><span class="nx">ConstM</span><span class="p">()</span><span class="w"> </span><span class="nx">Group</span><span class="w">
       </span><span class="nx">ConstN</span><span class="p">()</span><span class="w"> </span><span class="nx">Group</span><span class="w">
       </span><span class="nx">ConstS</span><span class="p">()</span><span class="w"> </span><span class="nx">Group</span><span class="w">

       </span><span class="nx">RandomScalar</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w">
       </span><span class="nx">PasswordToScalar</span><span class="p">(</span><span class="nx">pw</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="w">

       </span><span class="nx">ElementToBytes</span><span class="p">(</span><span class="nx">ele</span><span class="w"> </span><span class="nx">Group</span><span class="p">)</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="w">
       </span><span class="nx">ElementFromBytes</span><span class="p">(</span><span class="nx">b</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">)</span><span class="w"> </span><span class="nx">Group</span><span class="w">

       </span><span class="nx">BasePointMult</span><span class="p">(</span><span class="nx">s</span><span class="w"> </span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span><span class="w"> </span><span class="nx">Group</span><span class="w">
       </span><span class="nx">Add</span><span class="p">(</span><span class="nx">other</span><span class="w"> </span><span class="nx">Group</span><span class="p">)</span><span class="w"> </span><span class="nx">Group</span><span class="w">
       </span><span class="nx">ScalarMult</span><span class="p">(</span><span class="nx">s</span><span class="w"> </span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span><span class="w"> </span><span class="nx">Group</span><span class="w">

       </span><span class="nx">ElementSize</span><span class="p">()</span><span class="w"> </span><span class="kt">int</span><span class="w">
</span><span class="p">}</span>
</pre><p>Remember this was not final version which I reached but initial version. I kept this under <cite>group.go</cite> file. I also thought it would be better to keep group implementations outside SPAKE2. So I created SPAKE2 as <cite>salsa.debian.org/vasudev/gospake2</cite> Ed25519 group operations under <cite>salsa.debian.org/vasudev/ed25519group</cite> and integergroup operations under <cite>salsa.debian.org/vasudev/integergroup</cite>.</p><p>I hit my first road block with this representation. I created a type <cite>Ed25519</cite> in <cite>ed25519group</cite> package and implemented the <cite>Group</cite> interface above but instead of function accepting/returning <cite>Group</cite> I used <cite>Ed25519</cite>. This felt natural to me as <cite>Ed25519</cite> was confimring to <cite>Group</cite> interface but that Go compiler thought otherwise. Go compiler refused to agree <cite>Ed25519</cite> type implemented <cite>Group</cite> interface and told the defintion of functions do not match. For eg. it said for ConstM, <strong>expected return value of Group but found Ed25519</strong>. I did not yet figure out why this does not work, but as far as I can understand this happens because when Go compiler scans ConstM line it still does not know that type <cite>Ed25519</cite> implements <cite>Group</cite> interface. I could have asked in forums but frankly I did not know how to phrase this question :). If you are a gopher and know the answer please do let me know :).</p><p>Without spending too much time to figure out why its not working, I changed the interface definition to look like below.</p><pre class="code go literal-block">
<span class="kd">type</span><span class="w"> </span><span class="nx">Group</span><span class="w"> </span><span class="kd">interface</span><span class="w"> </span><span class="p">{</span><span class="w">
       </span><span class="nx">ConstM</span><span class="p">()</span><span class="w"> </span><span class="kd">interface</span><span class="p">{}</span><span class="w">
       </span><span class="nx">ConstN</span><span class="p">()</span><span class="w"> </span><span class="kd">interface</span><span class="p">{}</span><span class="w">
       </span><span class="nx">ConstS</span><span class="p">()</span><span class="w"> </span><span class="kd">interface</span><span class="p">{}</span><span class="w">

       </span><span class="nx">RandomScalar</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w">
       </span><span class="nx">PasswordToScalar</span><span class="p">(</span><span class="nx">pw</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="w">

       </span><span class="nx">ElementToBytes</span><span class="p">(</span><span class="nx">ele</span><span class="w"> </span><span class="kd">interface</span><span class="p">{})</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="w">
       </span><span class="nx">ElementFromBytes</span><span class="p">(</span><span class="nx">b</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">)</span><span class="w"> </span><span class="kd">interface</span><span class="p">{}</span><span class="w">

       </span><span class="nx">BasePointMult</span><span class="p">(</span><span class="nx">s</span><span class="w"> </span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span><span class="w"> </span><span class="kd">interface</span><span class="p">{}</span><span class="w">
       </span><span class="nx">Add</span><span class="p">(</span><span class="nx">other</span><span class="w"> </span><span class="kd">interface</span><span class="p">{})</span><span class="w"> </span><span class="kd">interface</span><span class="p">{}</span><span class="w">
       </span><span class="nx">ScalarMult</span><span class="p">(</span><span class="nx">s</span><span class="w"> </span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span><span class="w"> </span><span class="kd">interface</span><span class="p">{}</span><span class="w">

       </span><span class="nx">ElementSize</span><span class="p">()</span><span class="w"> </span><span class="kt">int</span><span class="w">
</span><span class="p">}</span>
</pre><p>So now compiler is happy because <cite>interface{}</cite> means any type. Though I was not happy because I had to do lot of type assertions in the actual implementation of group.</p><p>After I did first version of ed25519group and successfuly used it in gospake2 0.1.0, I was feeling something was not correct and things needs to be improved. Then when I started to implement <cite>integergroup</cite> package things started becoming more clear to me. I finished writing <cite>integergroup</cite> with same interface definition as above.</p><p>After both groups are implemented and integrated into gospake2, I started to look at python code moe carefully. A pattern started emerging in my mind. Python code was structured to differentiate Group and its elements, and this seemed natural separation. Once you separat Elements your interface definition will become more simpler.</p><p>So after struggling a bit I wrote a new interface, now differentiating Elements and Group itself. The final code as of writing this post is below.</p><pre class="code go literal-block">
<span class="c1">// Element represents the operation that needs to be satisfied by Group element.</span><span class="w">
</span><span class="kd">type</span><span class="w"> </span><span class="nx">Element</span><span class="w"> </span><span class="kd">interface</span><span class="w"> </span><span class="p">{</span><span class="w">
     </span><span class="nx">Add</span><span class="p">(</span><span class="nx">other</span><span class="w"> </span><span class="nx">Element</span><span class="p">)</span><span class="w"> </span><span class="nx">Element</span><span class="w">
     </span><span class="nx">ScalarMult</span><span class="p">(</span><span class="nx">s</span><span class="w"> </span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span><span class="w"> </span><span class="nx">Element</span><span class="w">
     </span><span class="nx">Negate</span><span class="p">()</span><span class="w"> </span><span class="nx">Element</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="c1">// Group defines methods that needs to be implemented by the number / elliptic</span><span class="w">
</span><span class="c1">// curve group which is used to implement SPAKE2 algorithm</span><span class="w">
</span><span class="kd">type</span><span class="w"> </span><span class="nx">Group</span><span class="w"> </span><span class="kd">interface</span><span class="w"> </span><span class="p">{</span><span class="w">
     </span><span class="c1">// These functions are not really group operations but they are needed</span><span class="w">
     </span><span class="c1">// to get the required group Element's needed for calculation of SPAKE2</span><span class="w">
     </span><span class="nx">ConstM</span><span class="p">()</span><span class="w"> </span><span class="nx">Element</span><span class="w">
     </span><span class="nx">ConstN</span><span class="p">()</span><span class="w"> </span><span class="nx">Element</span><span class="w">
     </span><span class="nx">ConstS</span><span class="p">()</span><span class="w"> </span><span class="nx">Element</span><span class="w">

     </span><span class="c1">// This operation is needed to get a random integer in the group</span><span class="w">
     </span><span class="nx">RandomScalar</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w">

     </span><span class="c1">// This operation is for converting user password to a group element</span><span class="w">
     </span><span class="nx">PasswordToScalar</span><span class="p">(</span><span class="nx">pw</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="w">

     </span><span class="c1">// These operations are group operations</span><span class="w">
     </span><span class="nx">BasePointMult</span><span class="p">(</span><span class="nx">s</span><span class="w"> </span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span><span class="w"> </span><span class="nx">Element</span><span class="w">
     </span><span class="nx">Add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="nx">Element</span><span class="p">)</span><span class="w"> </span><span class="nx">Element</span><span class="w">
     </span><span class="nx">ScalarMult</span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="nx">Element</span><span class="p">,</span><span class="w"> </span><span class="nx">s</span><span class="w"> </span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span><span class="w"> </span><span class="nx">Element</span><span class="w">

     </span><span class="nx">ElementToBytes</span><span class="p">(</span><span class="nx">e</span><span class="w"> </span><span class="nx">Element</span><span class="p">)</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="w">
     </span><span class="nx">ElementFromBytes</span><span class="p">([]</span><span class="kt">byte</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nx">Element</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w">

     </span><span class="c1">// This operation should return size of the group</span><span class="w">
     </span><span class="nx">ElementSize</span><span class="p">()</span><span class="w"> </span><span class="kt">int</span><span class="w">

     </span><span class="c1">// This operation returns order of subgroup</span><span class="w">
     </span><span class="nx">Order</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="w">
</span><span class="p">}</span>
</pre><p>Element interface requires implementer to implement <cite>Add</cite>, <cite>ScalarMult</cite> and <cite>Negate</cite> function. Group interface also has <cite>Add</cite> and <cite>ScalarMult</cite> operation but Group functions require you to pass Element as input and returns Element as output. Though it may be redundant it gives a natural organization to code.</p><p>With new interface new group implementations don't have to do too much type assertions but there will still be some which can't be avoided (eg. Element to actual type).</p></div><div class="section" id="packages-subpackages-and"><h2>Packages, Subpackages and....</h2><p>Well there is no such thing called subpackage in Go, this is one of the learning I had while writing <em>gospake2</em> and related <em>group</em> implementation. I first created the <em>Group</em> interface in file called <cite>group.go</cite> which was under <cite>salsa.debian.org/vasudev/gospake2</cite> package. So to refer Group interface I just need to import gospake2 and refer it as <cite>gospake2.Group</cite>. In the beginning this seemed correct approach as I did not directly refer the <cite>Group</cite> interface in the first versions of <cite>ed25519group</cite> and <cite>integergroup</cite>. (The version where I used <cite>interface{}</cite> extensively). But when I refactored to have 2 interfaces above I got cyclic dependency error. ed25519group and integergroup both referred gospake2.Group and gospake2 referred these groups.</p><p>So to fix the error I moved the interface declaration from <em>group.go</em> to <em>groups</em> folder under gospake2 package, and made it package <em>groups</em>. Few points I learned while doing this is</p><ul class="simple"><li>Even if the package is inside your package you can't directly use it. i.e. there is no such thing as subpackage. gospake2 had to refer groups with its full namespace i.e. <cite>salsa.debian.org/vasudev/gospake2/groups</cite></li><li>Folder structure inside package does not directly relate to each other, its just placing them in meaningful path like <cite>crypto/sha256</cite> and <cite>crypto/sha512</cite> they do not mean they are related its just that they fall under cryptography.</li><li>Standard library can refer to interface in parent package, for example <cite>crypto/ecdsa</cite> can refer to <cite>crypto.SignerOpts</cite> interface which is defined in crypto package just by importing &quot;crypto&quot; inside ecdsa package. This works because <em>crypto</em> is package name in GOPATH, but there is nothing special here. For us to refer something in so called parent package we need to use fullpath for example <cite>salsa.debian.org/vasudev/gospake2/groups</cite> because that is how user packages are namespaced under GOPATH.</li></ul><p>So finally I got a proper layout for <cite>Group</cite> and <cite>Element</cite> interfaces, its now available under <cite>salsa.debian.org/vasudev/gospake2/groups</cite> package. If you intend to provide a new group implementation for gospake2 you need to implement these interfaces in your package.</p></div><div class="section" id="implementing-ed25519-group"><h2>Implementing Ed25519 Group</h2><p>Implementing Ed25519 group was a bit of adventurous journey. First I searched for ready made implementation if any. Only thing I found was <cite>golang.org/x/crypto/ed25519/internal/edwards25519</cite> which is port of DJB's original C code to Go by Adam Langley. Problem was this package was internal to <cite>ed25519</cite> package and Go compiler would refuse to allow you import it outside the ed25519 package. So I decided to embed <em>edwards25519</em> as a internal package with in <cite>gospake2</cite>. This was prior to second version of <cite>Group</cite> interface design.</p><p>Even with embedding I could not really use it properly. I could get the BasePointMult operation working but nothing else worked and naively I tried to use <cite>ScMulAdd</cite> for Scalar multiplication which was really a wrong thing to do. Later I understood that the module was specifically written for Ed25519 signature scheme. Though it might still be possible to use it now that I've understood the basics of curve, I will definitely give it a second try at later point in time.</p><p>After the failed attempt with edwards25519 Ramakrishnan suggested me to use big integer and implement those methods myself and finally that is what I did. I used <cite>math/big</cite> package to implement the operations required myself. So the experience of writing this module taught me a lot. Below are few of my learnings.</p><div class="section" id="annoyance-with-big-int"><h3>Annoyance with big.Int</h3><p>While using big.Int I was annoyed by the specific syntax which invovled invoking the operation using a big.Int variable which will set the result to same variable and additionally return same value also. This design felt redundant to me and also I had to create so many intermediate variables to get operations like Add or Double implemented. Are you thinking why?. Then look at below formula for Add to add 2 points <cite>P1 = (X1,Y1,T1,Z1)</cite> and <cite>P2 = (X2, Y2, T2. Z2)</cite></p><pre class="code python literal-block">
<span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">Y1</span><span class="o">-</span><span class="n">X1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Y2</span><span class="o">-</span><span class="n">X2</span><span class="p">)</span><span class="w">
</span><span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">Y1</span><span class="o">+</span><span class="n">X1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Y2</span><span class="o">+</span><span class="n">X2</span><span class="p">)</span><span class="w">
</span><span class="n">C</span> <span class="o">=</span> <span class="n">T1</span><span class="o">*</span><span class="n">k</span><span class="o">*</span><span class="n">T2</span><span class="w">
</span><span class="n">D</span> <span class="o">=</span> <span class="n">Z1</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">Z2</span><span class="w">
</span><span class="n">E</span> <span class="o">=</span> <span class="n">B</span><span class="o">-</span><span class="n">A</span><span class="w">
</span><span class="n">F</span> <span class="o">=</span> <span class="n">D</span><span class="o">-</span><span class="n">C</span><span class="w">
</span><span class="n">G</span> <span class="o">=</span> <span class="n">D</span><span class="o">+</span><span class="n">C</span><span class="w">
</span><span class="n">H</span> <span class="o">=</span> <span class="n">B</span><span class="o">+</span><span class="n">A</span><span class="w">
</span><span class="n">X3</span> <span class="o">=</span> <span class="n">E</span><span class="o">*</span><span class="n">F</span><span class="w">
</span><span class="n">Y3</span> <span class="o">=</span> <span class="n">G</span><span class="o">*</span><span class="n">H</span><span class="w">
</span><span class="n">T3</span> <span class="o">=</span> <span class="n">E</span><span class="o">*</span><span class="n">H</span><span class="w">
</span><span class="n">Z3</span> <span class="o">=</span> <span class="n">F</span><span class="o">*</span><span class="n">G</span>
</pre><p>With big.Int I had to create every intermediate variable and then calculate their result, for eg. (Y1-X1) and (Y2 - X2) and then finally calculate A. At this point I started liking C++ more as it will allow me to override + operator ;-). But at later point I noticed some Go code where people dealt with the big.Int in following format</p><pre class="code go literal-block">
<span class="nx">Y1MX1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">).</span><span class="nx">Sub</span><span class="p">(</span><span class="nx">Y1</span><span class="p">,</span><span class="w"> </span><span class="nx">X1</span><span class="p">)</span><span class="w">
</span><span class="nx">Y2MX2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">).</span><span class="nx">Sub</span><span class="p">(</span><span class="nx">Y2</span><span class="p">,</span><span class="w"> </span><span class="nx">X2</span><span class="p">)</span><span class="w">
</span><span class="nx">A</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">).</span><span class="nx">Mul</span><span class="p">(</span><span class="nx">Y1MX1</span><span class="p">,</span><span class="w"> </span><span class="nx">Y2MX2</span><span class="p">)</span>
</pre><p>It reduced intermediate variables to some extent, additionally it avoids declaring required variables first and then use it. But still its bit of annoyance :).</p></div><div class="section" id="confusions-with-pointers"><h3>Confusions with Pointers</h3><p>When using local variables of type big.Int and returning a pointer to it, I started to have a doubt that if what I'm doing is correct. Being from C background where you are not supposed to be returning pointer to a stack variable, Go's ability to return address of local variable confused me. But it looks like <a class="reference external" href="https://stackoverflow.com/questions/38234487/go-returning-a-pointer-on-stack#38234526">Go compiler is smarter in this aspect</a>. Basically Go compiler does escape analysis to figure out if variable leaves after function and if so it moves it to garbage collected heap. So basically as Go programmer I need not bother on where my variables are allocated. Thats a relief :).</p></div><div class="section" id="type-aliasing-in-go"><h3>Type Aliasing in Go</h3><p>Type aliasing in languages like Rust or C++ is a handy way to create alternate name for previously created type. This just creates a new name for existing type and you can still use the original types methods or variables. But this is not the same case in Go. Go <a class="reference external" href="https://golang.org/ref/spec#Type_declarations">language spec</a>. clearly says that new type does not derive anything from originl type. But compiler allows you to cast to-and-fro from original to new type and vice versa.</p><p>I was bit by this as I did not knew about it. I created a alias for ExtendedPoint type as Ed25519 to implement Group interface. But when I tried to access original functions from ExtendedPoint I noticed this behavior. So I had to write private conversion function just to cast types around.</p></div><div class="section" id="implementing-scalar-multiplication-and-stack-exhaustion"><h3>Implementing Scalar Multiplication and stack exhaustion</h3><p>Implementing scalar multiplication was one of the last adventure I tackled in the ed25519 group implementation. Scalar multiplication is multiplying a given elliptic curve point with a large integer (otherwise called as scalar) limited by subgroup order. Warner's python implementation was as follows</p><pre class="code python literal-block">
<span class="k">def</span> <span class="nf">scalarmult_element</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span> <span class="c1"># extended-&gt;extended</span><span class="w">
</span>  <span class="c1"># This form only works properly when given points that are a member of</span><span class="w">
</span>  <span class="c1"># the main 1*L subgroup. It will give incorrect answers when called with</span><span class="w">
</span>  <span class="c1"># the points of order 1/2/4/8, including point Zero. (it will also work</span><span class="w">
</span>  <span class="c1"># properly when given points of order 2*L/4*L/8*L)</span><span class="w">
</span>  <span class="k">assert</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="w">
</span>  <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span><span class="w">
</span>      <span class="k">return</span> <span class="n">xform_affine_to_extended</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="w">
</span>  <span class="n">_</span> <span class="o">=</span> <span class="n">double_element</span><span class="p">(</span><span class="n">scalarmult_element</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">))</span><span class="w">
</span>  <span class="k">return</span> <span class="n">_add_elements_nonunfied</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">pt</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span><span class="o">&amp;</span><span class="mi">1</span> <span class="k">else</span> <span class="n">_</span>
</pre><p>Though I don't exactly remember first version of my scalar multiplication function, it was mimicking the python code in Go with big.Int. The code worked well with small integers but when I gave big numbers generated using <cite>RandomScalar</cite> function of <cite>Group</cite> interface, code will panic as it will run out of stack.</p><p>Above python code is slightly optimized version, so I looked at Haskell implementation of SPAKE2 which looked like below</p><pre class="code haskell literal-block">
<span class="c1">-- | Scalar multiplication parametrised by addition.</span><span class="w">
</span><span class="nf">scalarMultiplyExtendedPoint</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">ExtendedPoint</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ExtendedPoint</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ExtendedPoint</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ExtendedPoint</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ExtendedPoint</span><span class="w"> </span><span class="n">a</span><span class="w">
</span><span class="nf">scalarMultiplyExtendedPoint</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">_</span><span class="w">    </span><span class="ow">=</span><span class="w"> </span><span class="n">extendedZero</span><span class="w">
</span><span class="nf">scalarMultiplyExtendedPoint</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">x</span><span class="w">
       </span><span class="o">|</span><span class="w"> </span><span class="n">even</span><span class="w"> </span><span class="n">n</span><span class="w">    </span><span class="ow">=</span><span class="w"> </span><span class="n">doubleExtendedPoint</span><span class="w"> </span><span class="p">(</span><span class="n">scalarMultiplyExtendedPoint</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="p">`</span><span class="n">div</span><span class="p">`</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w">
       </span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w">    </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w">
       </span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="w">    </span><span class="ow">=</span><span class="w"> </span><span class="n">panic</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="s">&quot;Unexpected negative multiplier: &quot;</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="n">n</span><span class="w">
       </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="n">scalarMultiplyExtendedPoint</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
</pre><p>So algorithm is like this</p><ol class="arabic simple"><li>If scalar is 1 return same point</li><li>If scalar is 0 return identity element for group</li><li>If scalar is even then recursively call scalarmult by reducing the scalar to half and double the result.</li><li>Otherwise recursively scalarmultiply the point with scalar reduced by 1 and add the result to the point.</li></ol><p>It might look slightly confusing explanation so I will just show the code below.</p><pre class="code go literal-block">
<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">e</span><span class="w"> </span><span class="o">*</span><span class="nx">ExtendedPoint</span><span class="p">)</span><span class="w"> </span><span class="nx">ScalarMultSlow</span><span class="p">(</span><span class="nx">s</span><span class="w"> </span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span><span class="w"> </span><span class="nx">ExtendedPoint</span><span class="w"> </span><span class="p">{</span><span class="w">
     </span><span class="k">if</span><span class="w"> </span><span class="nx">s</span><span class="p">.</span><span class="nx">Cmp</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">NewInt</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
             </span><span class="k">return</span><span class="w"> </span><span class="nx">Zero</span><span class="w">
     </span><span class="p">}</span><span class="w">

     </span><span class="k">if</span><span class="w"> </span><span class="nx">s</span><span class="p">.</span><span class="nx">Cmp</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">NewInt</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
             </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="nx">e</span><span class="w">
     </span><span class="p">}</span><span class="w">

     </span><span class="kd">var</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="nx">ExtendedPoint</span><span class="w">
     </span><span class="k">if</span><span class="w"> </span><span class="nx">IsEven</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
             </span><span class="c1">// If scalar is even we recursively call scalarmult with n/2 and</span><span class="w">
             </span><span class="c1">// then double the result.</span><span class="w">
             </span><span class="nx">result</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">e</span><span class="p">.</span><span class="nx">ScalarMultSlow</span><span class="p">(</span><span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">).</span><span class="nx">Rsh</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">
             </span><span class="nx">result</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">result</span><span class="p">.</span><span class="nx">Double</span><span class="p">()</span><span class="w">
     </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
             </span><span class="c1">// We decrement the scalar and recursively call scalarmult with</span><span class="w">
             </span><span class="c1">// it then we add the result with point</span><span class="w">
             </span><span class="nx">result</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">e</span><span class="p">.</span><span class="nx">ScalarMultSlow</span><span class="p">(</span><span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">).</span><span class="nx">Sub</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="w"> </span><span class="nx">big</span><span class="p">.</span><span class="nx">NewInt</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span><span class="w">
             </span><span class="nx">result</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">AddUnified</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="nx">e</span><span class="p">)</span><span class="w">
     </span><span class="p">}</span><span class="w">

     </span><span class="k">return</span><span class="w"> </span><span class="nx">result</span><span class="w">
</span><span class="p">}</span>
</pre><p>So instead of dividing by 2 I just right shift the scalar by 1 which is faster operation. (AddUnified is one of the algorithm for point addition which is more safer but slower alternative, hence the name ScalarMultSlow.)</p><p>So this implementation works with every input, except the negative one for which I modified ScalarMult definition in Group level to reduce input scalar to subgroup order L. Otherwise Group function just calls function from Element. Code below.</p><pre class="code go literal-block">
<span class="c1">// ScalarMult multiples given point with scalar and returns the result</span><span class="w">
</span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">e</span><span class="w"> </span><span class="nx">Ed25519</span><span class="p">)</span><span class="w"> </span><span class="nx">ScalarMult</span><span class="p">(</span><span class="nx">a</span><span class="w"> </span><span class="nx">group</span><span class="p">.</span><span class="nx">Element</span><span class="p">,</span><span class="w"> </span><span class="nx">s</span><span class="w"> </span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span><span class="w"> </span><span class="nx">group</span><span class="p">.</span><span class="nx">Element</span><span class="w"> </span><span class="p">{</span><span class="w">
     </span><span class="c1">// First let's reduce s to curve order, this is important in case if we</span><span class="w">
     </span><span class="c1">// pass negated value</span><span class="w">
     </span><span class="nx">s</span><span class="p">.</span><span class="nx">Mod</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="w"> </span><span class="nx">L</span><span class="p">)</span><span class="w">
     </span><span class="k">if</span><span class="w"> </span><span class="nx">s</span><span class="p">.</span><span class="nx">Cmp</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">NewInt</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
             </span><span class="k">return</span><span class="w"> </span><span class="nx">Zero</span><span class="w">
     </span><span class="p">}</span><span class="w">

     </span><span class="nx">extendedPoint</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">a</span><span class="p">.(</span><span class="nx">ExtendedPoint</span><span class="p">)</span><span class="w">
     </span><span class="nx">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">extendedPoint</span><span class="p">.</span><span class="nx">ScalarMult</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="w">
     </span><span class="k">return</span><span class="w"> </span><span class="nx">result</span><span class="w">
</span><span class="p">}</span>
</pre><p>Probably I shoud move reducing the scalar to subgroup order into scalarmult inside Element's implementation.</p></div></div><div class="section" id="implementing-integer-group"><h2>Implementing Integer Group</h2><p>Given the problems I faced and things I learnt, implementing Ed25519 group, implementing integer group was much straight forward. Only some design decisions had to be made.</p><div class="section" id="how-to-represent-group-and-elements"><h3>How to Represent Group and Elements</h3><p>Unlike Ed25519 where group elements are basically points on the curve, element in multiplicative integer groups are basically integers. So how do I represent various integer groups?. Various integer groups are differentiated by bit length of elements in it, group and subgroup order. Looking at python code I created a structure called <cite>GroupParameters</cite> which will contain necessary information for a given group.</p><pre class="code go literal-block">
<span class="kd">type</span><span class="w"> </span><span class="nx">GroupParameters</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
       </span><span class="nx">p</span><span class="p">,</span><span class="w"> </span><span class="nx">q</span><span class="p">,</span><span class="w"> </span><span class="nx">g</span><span class="w"> </span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="w">
       </span><span class="nx">elementSizeBytes</span><span class="p">,</span><span class="w"> </span><span class="nx">elementSizeBits</span><span class="p">,</span><span class="w"> </span><span class="nx">scalarSize</span><span class="w"> </span><span class="kt">int</span><span class="w">
</span><span class="p">}</span>
</pre><p>I did not want to export these fields as they are not useful outside the package. Python code implemented 3 integer group of 1024,2048 and 3072 bit integers. All values for above variables were taken from <a class="reference external" href="http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/DSA2_All.pdf">NIST document</a>.</p><p>In first iteration I only had a struct called <cite>IntegerGroup</cite> which had parameters as member and implemented <cite>Group</cite> interface from gospake2. But when I refactored Group interface to have Element interface refactoring the code for integergroup became bit challenging. I introduced <cite>IntegerElement</cite> struct to hold actual integer value, but since all operations needed access to order of group I had to modify it to also contain parameters defined above. So final definition of <cite>IntegerGroup</cite> and <cite>IntegerElement</cite> is as follows</p><pre class="code go literal-block">
<span class="kd">type</span><span class="w"> </span><span class="nx">IntegerGroup</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
       </span><span class="nx">params</span><span class="w"> </span><span class="o">*</span><span class="nx">GroupParameters</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="kd">type</span><span class="w"> </span><span class="nx">IntegerElement</span><span class="w"> </span><span class="p">{</span><span class="w">
       </span><span class="nx">params</span><span class="w"> </span><span class="o">*</span><span class="nx">GroupParameters</span><span class="w">
       </span><span class="nx">e</span><span class="w"> </span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="w">
</span><span class="p">}</span>
</pre><p>Operations in <cite>IntegerGroup</cite> were simply calling functions from <cite>IntegerElement</cite>. So its really redundant but to make sure I can distinguish between both group and its element I had to use it in this form.</p></div><div class="section" id="scalar-multiplication-and-addition-operations"><h3>Scalar Multiplication and Addition Operations</h3><p>Since the integer groups are really multiplicative group, addition operation is really a multiplication modulo p. Scalar multiplication is just exponentiation modulo p. Since these operations are readily available in <cite>math/big</cite> I did not had to do anything much for integer group. These operations in <cite>IntegerElement</cite> are defined as follows.</p><pre class="code go literal-block">
<span class="c1">// Add is actually multiplication mod `p` where `p` is order of the</span><span class="w">
</span><span class="c1">// multiplicative group</span><span class="w">
</span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="nx">IntegerElement</span><span class="p">)</span><span class="w"> </span><span class="nx">Add</span><span class="p">(</span><span class="nx">other</span><span class="w"> </span><span class="nx">group</span><span class="p">.</span><span class="nx">Element</span><span class="p">)</span><span class="w"> </span><span class="nx">group</span><span class="p">.</span><span class="nx">Element</span><span class="w"> </span><span class="p">{</span><span class="w">
     </span><span class="nx">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">i</span><span class="p">.</span><span class="nx">e</span><span class="w">
     </span><span class="nx">b</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">other</span><span class="p">.(</span><span class="nx">IntegerElement</span><span class="p">).</span><span class="nx">e</span><span class="w">

     </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">i</span><span class="p">.</span><span class="nx">params</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="nx">other</span><span class="p">.(</span><span class="nx">IntegerElement</span><span class="p">).</span><span class="nx">params</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
             </span><span class="nb">panic</span><span class="p">(</span><span class="s">&quot;You can't add elements of 2 different groups&quot;</span><span class="p">)</span><span class="w">
     </span><span class="p">}</span><span class="w">

     </span><span class="nx">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">).</span><span class="nx">Mul</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="p">)</span><span class="w">

     </span><span class="k">return</span><span class="w"> </span><span class="nx">group</span><span class="p">.</span><span class="nx">Element</span><span class="p">(</span><span class="nx">IntegerElement</span><span class="p">{</span><span class="nx">params</span><span class="p">:</span><span class="w"> </span><span class="nx">i</span><span class="p">.</span><span class="nx">params</span><span class="p">,</span><span class="w"> </span><span class="nx">e</span><span class="p">:</span><span class="w"> </span><span class="nx">result</span><span class="p">.</span><span class="nx">Mod</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">.</span><span class="nx">params</span><span class="p">.</span><span class="nx">p</span><span class="p">)})</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="c1">// ScalarMult for multiplicative group is g^s mod p where `g` is group generator</span><span class="w">
</span><span class="c1">// and p is order of the group</span><span class="w">
</span><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="nx">IntegerElement</span><span class="p">)</span><span class="w"> </span><span class="nx">ScalarMult</span><span class="p">(</span><span class="nx">s</span><span class="w"> </span><span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span><span class="w"> </span><span class="nx">group</span><span class="p">.</span><span class="nx">Element</span><span class="w"> </span><span class="p">{</span><span class="w">
     </span><span class="nx">reducedS</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">).</span><span class="nx">Mod</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">.</span><span class="nx">params</span><span class="p">.</span><span class="nx">q</span><span class="p">)</span><span class="w">
     </span><span class="k">return</span><span class="w"> </span><span class="nx">group</span><span class="p">.</span><span class="nx">Element</span><span class="p">(</span><span class="nx">IntegerElement</span><span class="p">{</span><span class="nx">params</span><span class="p">:</span><span class="w"> </span><span class="nx">i</span><span class="p">.</span><span class="nx">params</span><span class="p">,</span><span class="w"> </span><span class="nx">e</span><span class="p">:</span><span class="w"> </span><span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">).</span><span class="nx">Exp</span><span class="p">(</span><span class="nx">i</span><span class="p">.</span><span class="nx">e</span><span class="p">,</span><span class="w"> </span><span class="nx">reducedS</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">.</span><span class="nx">params</span><span class="p">.</span><span class="nx">p</span><span class="p">)})</span><span class="w">
</span><span class="p">}</span>
</pre></div></div><div class="section" id="conclussion"><h2>Conclussion</h2><p>Well its been already a pretty long post, so without extending it more I would like to say that I had lot of learning experience in writing the Go code to implement these integer and ed25519 group. Main learnings were</p><ol class="arabic simple"><li>There is no definite answer for any questions, may it be how to write a library or if I structured my library correctly. Of course there will be some best practice available but you have to start at some point and then improve it in iteration.</li><li>Go provides great tooling especially linters and formatters which makes you write a clean code. And also document all your exported functions as you write (else you will keep seeing warnings in your editor which is annoying).</li><li>Use your library yourself and you will see how you can improve it. If you are feeling uncomfortable with your own written API then that means others will too :).</li><li>Every language is designed for a specific purpose, if I'm feeling discomfort using some features of the language (I had problems with verbose error handling) then probably I'm less experienced with language and should see how others handle such things. There are many good projects which you can refer to and lern from.</li></ol><p>In the next post which should be last in series I will write about design decisions I made writing gospake2 package. Code for both ed25519 and integer groups are now merged into gospake2 as that is the right place for them. You can find the code for them in my <a class="reference external" href="https://salsa.debian.org/vasudev/gospake2">gospake2 repo</a>.</p></div></div><div id="footer"><p><italic>Tagged as: cryptography, go, golang, spake2, </italic></p></section></div><hr><div id="footer"> Site Proudly powered by <a href="http://getpelican.com/">Pelican</a></div></body></html>