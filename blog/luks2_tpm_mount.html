<!DOCTYPE html><html lang="en"><head><link href="https://fonts.googleapis.com/css?family=Cantarell" rel="stylesheet"><title>Using LUKS-Encrypted USB Stick with TPM2 Integration</title><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="https://copyninja.in/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Random Ramblings Full Atom Feed"><link href="https://copyninja.in/feeds/{slug}.atom.xml" type="application/atom+xml" rel="alternate" title="Random Ramblings Categories Atom Feed"><link rel="stylesheet" type="text/css" href="/theme/css/pygments.css"><link rel="stylesheet" type="text/css" href="/theme/css/default.css"><meta name="tags" content="systemd-cryptenroll"><meta name="tags" content="systemd"><meta name="tags" content="tpm2"><meta name="tags" content="luks2"><meta name="tags" content="mount"></head><body><div id="header" class="body"><div id="navigation"> | <a href="https://copyninja.in">Home</a> | | <a href="https://copyninja.in/about">About</a> | | <a href="https://copyninja.in/contact">Contact</a> | | <a href="https://copyninja.in/categories.html">Categories</a> | | <a href="https://copyninja.in/tags.html">Tags</a> | </div><h1><a href="https://copyninja.in/blog/luks2_tpm_mount.html">Using LUKS-Encrypted USB Stick with TPM2 Integration</a></h1></div><div id="content"><section id="content" class="body"><footer class="post-info"><p> Posted on Jul 09, 2023 By copyninja under devops </p></abbr></footer><div class="entry-content"><p>I use a LUKS-encrypted USB stick to store my GPG and SSH keys, which acts as a backup and portable key setup when working on different laptops. One inconvenience with LUKS-encrypted USB sticks is that you need to enter the password every time you want to mount the device, either through a Window Manager like KDE or using the <cite>cryptsetup luksOpen</cite> command. Fortunately, many laptops nowadays come equipped with TPM2 modules, which can be utilized to automatically decrypt the device and subsequently mount it. In this post, we'll explore the usage of <em>systemd-cryptenroll</em> for this purpose, along with udev rules and a set of scripts to automate the mounting of the encrypted USB.</p><p>First, ensure that your device has a TPM2 module. You can run the following command to check:</p><div class="highlight"><pre><span></span>sudo<span class="w"> </span>journalctl<span class="w"> </span>-k<span class="w"> </span>--grep<span class="o">=</span>tpm2
</pre></div><p>The output should resemble the following:</p><div class="highlight"><pre><span></span>Jul<span class="w"> </span><span class="m">08</span><span class="w"> </span><span class="m">18</span>:57:32<span class="w"> </span>bhairava<span class="w"> </span>kernel:<span class="w"> </span>ACPI:<span class="w"> </span>SSDT<span class="w"> </span>0x00000000BBEFC000<span class="w"> </span>0003C6<span class="w"> </span><span class="o">(</span>v02
LENOVO<span class="w"> </span>Tpm2Tabl<span class="w"> </span><span class="m">00001000</span><span class="w"> </span>INTL<span class="w"> </span><span class="m">20160422</span><span class="o">)</span><span class="w"> </span>Jul<span class="w"> </span><span class="m">08</span><span class="w"> </span><span class="m">18</span>:57:32<span class="w"> </span>bhairava<span class="w"> </span>kernel:
ACPI:<span class="w"> </span>TPM2<span class="w"> </span>0x00000000BBEFB000<span class="w"> </span><span class="m">000034</span><span class="w"> </span><span class="o">(</span>v03<span class="w"> </span>LENOVO<span class="w"> </span>TP-R0D<span class="w"> </span><span class="m">00000830</span>
PTEC<span class="w"> </span><span class="m">00000002</span><span class="o">)</span><span class="w"> </span>Jul<span class="w"> </span><span class="m">08</span><span class="w"> </span><span class="m">18</span>:57:32<span class="w"> </span>bhairava<span class="w"> </span>kernel:<span class="w"> </span>ACPI:<span class="w"> </span>Reserving<span class="w"> </span>TPM2<span class="w"> </span>table
memory<span class="w"> </span>at<span class="w"> </span><span class="o">[</span>mem<span class="w"> </span>0xbbefb000-0xbbefb033<span class="o">]</span>
</pre></div><p>You can also use the <cite>systemd-cryptenroll</cite> command to check for the availability of a TPM2 device on your laptop:</p><div class="highlight"><pre><span></span>systemd-cryptenroll<span class="w"> </span>--tpm2-device<span class="o">=</span>list
</pre></div><p>The output will be something like following:</p><div class="highlight"><pre><span></span>blog<span class="w"> </span>git:<span class="o">(</span>master<span class="o">)</span><span class="w"> </span>systemd-cryptenroll<span class="w"> </span>--tpm2-device<span class="o">=</span>list
PATH<span class="w">        </span>DEVICE<span class="w">      </span>DRIVER
/dev/tpmrm0<span class="w"> </span>MSFT0101:00<span class="w"> </span>tpm_tis
➜<span class="w">  </span>blog<span class="w"> </span>git:<span class="o">(</span>master<span class="o">)</span>
</pre></div><p>Next, ensure that you have connected your encrypted USB device. Note that <cite>systemd-cryptenroll</cite> only works with LUKS2 and not LUKS1. If your device is LUKS1-encrypted, you may encounter an error while enrolling the device, complaining about the LUKS2 superblock not found.</p><p>To determine if your device uses a LUKS1 header or LUKS2, use the <cite>cryptsetup luksDump &lt;device&gt;</cite> command. If it is LUKS1, the header will begin with:</p><div class="highlight"><pre><span></span>LUKS<span class="w"> </span>header<span class="w"> </span>information<span class="w"> </span><span class="k">for</span><span class="w"> </span>/dev/sdb1

Version:<span class="w">        </span><span class="m">1</span>
Cipher<span class="w"> </span>name:<span class="w">    </span>aes
Cipher<span class="w"> </span>mode:<span class="w">    </span>xts-plain64
Hash<span class="w"> </span>spec:<span class="w">      </span>sha256
Payload<span class="w"> </span>offset:<span class="w"> </span><span class="m">4096</span>
</pre></div><p>Converting from LUKS1 to LUKS2 is a simple process, but for safety, ensure that you backup the header using the <cite>cryptsetup luksHeaderBackup</cite> command. Once backed up, use the following command to convert the header to LUKS2:</p><div class="highlight"><pre><span></span>sudo<span class="w"> </span>cryptsetup<span class="w"> </span>convert<span class="w"> </span>--type<span class="w"> </span>luks2<span class="w"> </span>/dev/sdb1
</pre></div><p>After conversion, the header will look like this:</p><div class="highlight"><pre><span></span>Version:<span class="w">        </span><span class="m">2</span>
Epoch:<span class="w">          </span><span class="m">4</span>
Metadata<span class="w"> </span>area:<span class="w">  </span><span class="m">16384</span><span class="w"> </span><span class="o">[</span>bytes<span class="o">]</span>
Keyslots<span class="w"> </span>area:<span class="w">  </span><span class="m">2064384</span><span class="w"> </span><span class="o">[</span>bytes<span class="o">]</span>
UUID:<span class="w">           </span>000b2670-be4a-41b4-98eb-9adbd12a7616
Label:<span class="w">          </span><span class="o">(</span>no<span class="w"> </span>label<span class="o">)</span>
Subsystem:<span class="w">      </span><span class="o">(</span>no<span class="w"> </span>subsystem<span class="o">)</span>
Flags:<span class="w">          </span><span class="o">(</span>no<span class="w"> </span>flags<span class="o">)</span>
</pre></div><p>The next step is to enroll the new LUKS key for the encrypted device using <cite>systemd-cryptenroll</cite>. Run the following command:</p><div class="highlight"><pre><span></span>sudo<span class="w"> </span>systemd-cryptenroll<span class="w"> </span>--tpm2-device<span class="o">=</span>/dev/tpmrm0<span class="w"> </span>--tpm2-pcrs<span class="o">=</span><span class="s2">&quot;0+7&quot;</span><span class="w"> </span>/dev/sdb1
</pre></div><p>This command will prompt you to provide the existing key to unseal the device. It will then add a new random key to the volume, allowing it to be unlocked in addition to the existing keys. Additionally, it will bind this new key to PCRs 0 and 7, representing the system firmware and Secure Boot state.</p><p>If there is only one TPM device on the system, you can use <cite>--tpm2-device=auto</cite> to automatically select the device. To confirm that the new key has been enrolled, you can dump the LUKS configuration and look for a <cite>systemd-tpm2</cite> token entry, as well as an additional entry in the Keyslots section.</p><p>To test the setup, you can use the <cite>/usr/lib/systemd/systemd-cryptsetup</cite> command. Additionally, you can check if the device is unsealed by using <cite>lsblk</cite>:</p><div class="highlight"><pre><span></span>sudo<span class="w"> </span>/usr/lib/systemd/systemd-cryptsetup<span class="w"> </span>attach<span class="w"> </span>GPG_USB<span class="w"> </span><span class="s2">&quot;/dev/sdb1&quot;</span><span class="w"> </span>-<span class="w"> </span>tpm2-device<span class="o">=</span>auto

lsblk
</pre></div><p>The <cite>lsblk</cite> command should display the unsealed and mounted device, like this:</p><div class="highlight"><pre><span></span>NAME<span class="w">        </span>MAJ:MIN<span class="w"> </span>RM<span class="w">   </span>SIZE<span class="w"> </span>RO<span class="w"> </span>TYPE<span class="w">  </span>MOUNTPOINTS
sda<span class="w">           </span><span class="m">8</span>:0<span class="w">    </span><span class="m">0</span><span class="w"> </span><span class="m">223</span>.6G<span class="w">  </span><span class="m">0</span><span class="w"> </span>disk
├─sda1<span class="w">        </span><span class="m">8</span>:1<span class="w">    </span><span class="m">0</span><span class="w">   </span>976M<span class="w">  </span><span class="m">0</span><span class="w"> </span>part<span class="w">  </span>/boot/efi
└─sda2<span class="w">        </span><span class="m">8</span>:2<span class="w">    </span><span class="m">0</span><span class="w"> </span><span class="m">222</span>.6G<span class="w">  </span><span class="m">0</span><span class="w"> </span>part
<span class="w">  </span>└─root<span class="w">    </span><span class="m">254</span>:0<span class="w">    </span><span class="m">0</span><span class="w"> </span><span class="m">222</span>.6G<span class="w">  </span><span class="m">0</span><span class="w"> </span>crypt<span class="w"> </span>/
sdb<span class="w">           </span><span class="m">8</span>:16<span class="w">   </span><span class="m">1</span><span class="w">   </span><span class="m">7</span>.5G<span class="w">  </span><span class="m">0</span><span class="w"> </span>disk
└─sdb1<span class="w">        </span><span class="m">8</span>:17<span class="w">   </span><span class="m">1</span><span class="w">   </span><span class="m">7</span>.5G<span class="w">  </span><span class="m">0</span><span class="w"> </span>part
<span class="w">  </span>└─GPG_USB<span class="w"> </span><span class="m">254</span>:1<span class="w">    </span><span class="m">0</span><span class="w">   </span><span class="m">7</span>.5G<span class="w">  </span><span class="m">0</span><span class="w"> </span>crypt<span class="w"> </span>/media/vasudev/GPG_USB
</pre></div><div class="section" id="auto-mounting-the-device"><h2>Auto Mounting the device</h2><p>Now that we have solved the initial problem of unsealing the USB device using TPM2 instead of manually entering the key, the next step is to automatically mount the device upon insertion and remove the mapping when the device is removed. This can be achieved using the following udev rules:</p><div class="highlight"><pre><span></span>ACTION==&quot;add&quot;, KERNEL==&quot;sd*&quot;, ENV{DEVTYPE}==&quot;partition&quot;, ENV{ID_BUS}==&quot;usb&quot;, ENV{SYSTEMD_WANTS}=&quot;mount-gpg-usb@$env{DEVNAME}.service&quot;
ACTION==&quot;remove&quot;, KERNEL==&quot;sd*&quot;, ENV{DEVTYPE}==&quot;partition&quot;, ENV{ID_BUS}==&quot;usb&quot;, RUN+=&quot;/usr/local/bin/umount_enc_usb.sh &#39;%E{ID_FS_UUID}&#39;&quot;
</pre></div><p>When a device is added, a systemd service is triggered to mount the device at a specific location. Initially, I used a script with the <cite>RUN</cite> directive, but it resulted in an exit code of <cite>32</cite>. This might be due to <cite>systemd-cryptsetup</cite> taking some time to return, causing udev to time out. To address this, I opted to use a systemd service instead.</p><p>For device removal, even though the physical device is no longer present, the mapping may still remain, causing issues upon reinsertion. To resolve this, I created a script to close the luks mapping upon device removal.</p><p>Below are the systemd service and script files:</p><p><strong>mount_enc_usb.sh:</strong></p><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="nb">set</span><span class="w"> </span>-x

<span class="k">if</span><span class="w"> </span><span class="o">[[</span><span class="w"> </span><span class="s2">&quot;</span><span class="nv">$#</span><span class="s2">&quot;</span><span class="w"> </span>-ne<span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">]]</span><span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">    </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;</span><span class="k">$(</span>basename<span class="w"> </span><span class="nv">$0</span><span class="k">)</span><span class="s2"> &lt;device&gt;&quot;</span>
<span class="w">    </span><span class="nb">exit</span><span class="w"> </span><span class="m">1</span>
<span class="k">fi</span>

<span class="nv">device_uuid</span><span class="o">=</span><span class="s2">&quot;</span><span class="k">$(</span>blkid<span class="w"> </span>--output<span class="w"> </span>udev<span class="w"> </span><span class="nv">$1</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span><span class="nv">ID_FS_UUID</span><span class="o">=</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>cut<span class="w"> </span>-d<span class="o">=</span><span class="w"> </span>-f2<span class="k">)</span><span class="s2">&quot;</span>
<span class="k">if</span><span class="w"> </span><span class="o">[[</span><span class="w"> </span><span class="s2">&quot;</span><span class="nv">$device_uuid</span><span class="s2">&quot;</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>000b2670-be4a-41b4-98eb-9adbd12a7616<span class="w"> </span><span class="o">]]</span><span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">    </span><span class="c1"># Found our device, let&#39;s trigger systemd-cryptsetup</span>
<span class="w">    </span>/usr/lib/systemd/systemd-cryptsetup<span class="w"> </span>attach<span class="w"> </span>GPG_USB<span class="w"> </span><span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span><span class="w"> </span>-<span class="w"> </span>tpm2-device<span class="o">=</span>auto
<span class="w">    </span><span class="o">[[</span><span class="w"> </span>-d<span class="w"> </span>/media/vasudev/GPG_USB<span class="w"> </span><span class="o">]]</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">(</span>mkdir<span class="w"> </span>-p<span class="w"> </span>/media/vasudev/GPG_USB/<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>chown<span class="w"> </span>vasudev:vasudev<span class="w"> </span>/media/vasudev/GPG_USB<span class="o">)</span>
<span class="w">    </span>mount<span class="w"> </span>/dev/mapper/GPG_USB<span class="w"> </span>/media/vasudev/GPG_USB
<span class="k">else</span>
<span class="w">    </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Not the interested device. Ignoring.&quot;</span>
<span class="w">    </span><span class="nb">exit</span><span class="w"> </span><span class="m">0</span>
<span class="k">fi</span>
</pre></div><p><strong>umount_enc_usb.sh:</strong></p><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="k">if</span><span class="w"> </span><span class="o">[[</span><span class="w"> </span><span class="s2">&quot;</span><span class="nv">$#</span><span class="s2">&quot;</span><span class="w"> </span>-ne<span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">]]</span><span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">  </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;</span><span class="k">$(</span>basename<span class="w"> </span><span class="nv">$0</span><span class="k">)</span><span class="s2"> &lt;fsuuid&gt;&quot;</span>
<span class="w">  </span><span class="nb">exit</span><span class="w"> </span><span class="m">1</span>
<span class="k">fi</span>

<span class="k">if</span><span class="w"> </span><span class="o">[[</span><span class="w"> </span><span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">&quot;000b2670-be4a-41b4-98eb-9adbd12a7616&quot;</span><span class="w"> </span><span class="o">]]</span><span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">  </span><span class="c1"># Our device is removed, let&#39;s close the luks mapping</span>
<span class="w">  </span><span class="o">[[</span><span class="w"> </span>-e<span class="w"> </span>/dev/mapper/GPG_USB<span class="w"> </span><span class="o">]]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>cryptsetup<span class="w"> </span>luksClose<span class="w"> </span>/dev/mapper/GPG_USB
<span class="k">else</span>
<span class="w">  </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Not our device.&quot;</span>
<span class="w">  </span><span class="nb">exit</span><span class="w"> </span><span class="m">0</span>
<span class="k">fi</span>
</pre></div><p><strong>mount-gpg-usb&#64;.service:</strong></p><div class="highlight"><pre><span></span><span class="k">[Unit]</span>
<span class="na">Description</span><span class="o">=</span><span class="s">Mount the encrypted USB device service</span>

<span class="k">[Service]</span>
<span class="na">Type</span><span class="o">=</span><span class="s">simple</span>
<span class="na">ExecStart</span><span class="o">=</span><span class="s">/usr/local/bin/mount_enc_usb.sh</span>
</pre></div><p>With this setup, plugging in the USB device will automatically unseal and mount it, and upon removal, the luks mapping will be closed.</p><div class="admonition note"><p class="first admonition-title">Note</p><p class="last">This can be even done for LUKS2 encrypted root disk but will need some tweaking in initramfs.</p></div></div><div class="section" id="references"><h2>References</h2><ol class="arabic simple"><li><a class="reference external" href="https://wiki.archlinux.org/title/Trusted_Platform_Module">Trusted Platform Module Arch Wiki</a></li><li><a class="reference external" href="https://www.reddit.com/r/openSUSE/comments/oydwuz/unable_to_use_systemdcryptenroll/">systemd-cryptenroll issue with LUKS1</a></li><li><a class="reference external" href="https://www.baeldung.com/linux/shell-run-script-usb-plugged">Execute shell script when USB Device is plugged</a></li></ol></div></div><div id="footer"><p><italic>Tagged as: luks2, mount, systemd, systemd-cryptenroll, tpm2, </italic></p></section></div><hr><div id="footer"> Site Proudly powered by <a href="http://getpelican.com/">Pelican</a></div></body></html>