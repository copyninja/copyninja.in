<!DOCTYPE html><html lang="en"><head><link href="https://fonts.googleapis.com/css?family=Cantarell" rel="stylesheet"><title>Writing a UDP Broadcast Receiver as Python Iterator</title><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="https://copyninja.in/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Random Ramblings Full Atom Feed"><link href="https://copyninja.in/feeds/{slug}.atom.xml" type="application/atom+xml" rel="alternate" title="Random Ramblings Categories Atom Feed"><link rel="stylesheet" type="text/css" href="/theme/css/pygments.css"><link rel="stylesheet" type="text/css" href="/theme/css/default.css"><meta name="tags" content="python"><meta name="tags" content="iterators"><meta name="tags" content="udp server"></head><body><div id="header" class="body"><div id="navigation"> | <a href="https://copyninja.in">Home</a> | | <a href="https://copyninja.in/about">About</a> | | <a href="https://copyninja.in/contact">Contact</a> | | <a href="https://copyninja.in/categories.html">Categories</a> | | <a href="https://copyninja.in/tags.html">Tags</a> | </div><h1><a href="https://copyninja.in/blog/udp-server-as-generator.html">Writing a UDP Broadcast Receiver as Python Iterator</a></h1></div><div id="content"><section id="content" class="body"><footer class="post-info"><p> Posted on Aug 19, 2017 By copyninja under development </p></abbr></footer><div class="entry-content"><p>I had to write a small Python application to listen for some broadcast message and process the message. This broadcast messages are actually sort of discovery messages to find some peers in a network. Writing a simple UDP Server to listen on a particular port was easy; but while designing an application I was wondering how can I plugin this server into my main code. There are 2 possibility</p><ol class="arabic simple"><li>Use threading module of python to send the server code in back ground and give it a callback to communicate the data to main thread.</li><li>Periodically read some messages from server code and then dispose of server.</li></ol><p>I didn't like first approach because I need to pass a callback function and I some how will end up complicating code. Second approach sounded sane but I did want to make server more like <em>iterator</em>. I searched around to see if some one has attempted to write something similar, but did not find anything useful (may be my Googling skills aren't good enough). Anyway so I thought what is wrong in trying?. If it works then I'll be happy that I did something different :-).</p><p>The first thing for making iterator in Python is having function <cite>__iter__</cite> and <cite>__next__</cite> defined in your class. For Python 2 iterator protocol wanted <cite>next</cite> to be defined instead of <cite>__next__</cite>. So for portable code you can define a <cite>next</cite> function which in return calls <cite>__next__</cite>.</p><p>So here is my first shot at writing <cite>BroadCastReceiver</cite> class.</p><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socket</span><span class="p">,</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_DGRAM</span>


<span class="k">class</span> <span class="nc">BroadCastReceiver</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">msg_len</span><span class="o">=</span><span class="mi">8192</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_DGRAM</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg_len</span> <span class="o">=</span> <span class="n">msg_len</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
             <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
             <span class="k">try</span><span class="p">:</span>
                 <span class="n">addr</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">recvfrom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg_len</span><span class="p">)</span>
                 <span class="k">return</span> <span class="n">addr</span><span class="p">,</span> <span class="n">data</span>
             <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                 <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Got exception trying to recv </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>
                 <span class="k">raise</span> <span class="ne">StopIteration</span>
</pre></div><p>This version of code can be used in a <cite>for</cite> loop to read from socket UDP broadcasts. One problem will be that if no packet is received which might be due to disconnected network the loop will just block forever. So I had to modify the code slightly to add timeout parameter. So changed portion of code is below.</p><div class="highlight"><pre><span></span><span class="o">...</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">msg_len</span><span class="o">=</span><span class="mi">8192</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">15</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_DGRAM</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">settimeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">msg_len</span> <span class="o">=</span> <span class="n">msg_len</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>

 <span class="o">...</span>
</pre></div><p>So now if network is disconnected or no packet was received for <cite>timeout</cite> period we get a <cite>socket.timeout</cite> exception due to which <cite>StopIteration</cite> will be raised causing the <cite>for</cite> loop using server as iterator to exit. This avoids us just blocking our periodic code run forever when network is disconnected or no messages are received for long time. (may be due to connected to wrong network).</p><p>Now every thing looks fine but only part is if we create the server object each time our periodic code is called we will have binding issue as we did not properly close the socket once iterator has stopped. So I added socket closing code in <cite>__del__</cite> function for the class. <cite>__del__</cite> will be called when garbage collector try to recollect object when it goes out of scope.</p><div class="highlight"><pre><span></span><span class="o">...</span>
    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div><p>So the server can be used in <cite>for</cite> loop or by passing the object of server to <cite>next</cite> built-in function. Here are 2 examples.</p><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="n">BroadCastReceiver</span><span class="p">(</span><span class="mi">5000</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Got packet from </span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">address</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># do whatever you want with data</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
        <span class="k">break</span>
</pre></div><p>Here we use an counter variable to track iteration and after some iteration we exit for loop. Another way is use <cite>for</cite> loop with range of iteration like below.</p><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="n">BroadCastReceiver</span><span class="p">(</span><span class="mi">5000</span><span class="p">,</span>  <span class="n">timeout</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">address</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="c1"># do whatever you want with data</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">break</span>
</pre></div><p>Here an additional try block was needed inside the for loop to card call to <cite>next</cite>, this is to handle the timeout or other exception and exit the loop. In first case this is not needed as <cite>StopIteration</cite> is understood by <cite>for</cite>.</p><p>Both use cases I described above are mostly useful when it is not critical to handle each and every packet (mostly peer discovery) and packets will always be sent. So if we miss some peers in one iteration we will still catch them in next iteration. We just need to make sure we provide big enough counter to catch most peers in each iteration.</p><p>If its critical to receive each packet we can safely send this iterating logic to a separate thread which keeps receiving packets and process data as needed.</p><p>For now I tried this pattern mostly with UDP protocol but I'm sure with some modification this can be used with TCP as well. I'll be happy to get feed back from Pythonistas out there on what you think of this approach. :-)</p><div class="section" id="update"><h2>Update</h2><p>I got a suggestion from <em>Ryan Nowakowski</em> to make the server object as <cite>context manager</cite> and close the socket in <cite>__exit__</cite> as it can't be guaranteed that <cite>__del__</cite> will be called for objects which exists during interpreter exits. So I slightly modified the class to add <cite>__enter__</cite> and <cite>__exit__</cite> method like below and removed <cite>__del__</cite></p><div class="highlight"><pre><span></span><span class="o">...</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div><p>Usage pattern is slightly modified because of this and we need to use <cite>with</cite> statement while creating object.</p><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">BroadCastReceiver</span><span class="p">(</span><span class="mi">2000</span><span class="p">)</span> <span class="k">as</span> <span class="n">r</span><span class="p">:</span>
    <span class="c1"># use server object as you wish</span>
    <span class="o">...</span>
</pre></div><p>It is also possible to cleanly close socket without adding context manager that is adding <cite>finally</cite> statement to our <cite>try</cite> and <cite>except</cite> block in <cite>__next__</cite>. The modified code without adding context manager looks like below.</p><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">addr</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">recvfrom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg_len</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">addr</span><span class="p">,</span> <span class="n">data</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Got exception trying to recv </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">StopIteration</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div><p>When we raise <cite>StopIteration</cite> again from except block, it will be temporarily saved and <cite>finally</cite> block is executed which will now close the socket.</p></div></div><div id="footer"><p><italic>Tagged as: iterators, python, udp server, </italic></p></section></div><hr><div id="footer"> Site Proudly powered by <a href="http://getpelican.com/">Pelican</a></div></body></html>