<!DOCTYPE html><html lang="en"><head><link href="https://fonts.googleapis.com/css?family=Cantarell" rel="stylesheet"><title>Docker container as Development Environment</title><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="https://copyninja.in/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Random Ramblings Full Atom Feed"><link href="https://copyninja.in/feeds/{slug}.atom.xml" type="application/atom+xml" rel="alternate" title="Random Ramblings Categories Atom Feed"><link rel="stylesheet" type="text/css" href="/theme/css/pygments.css"><link rel="stylesheet" type="text/css" href="/theme/css/default.css"><meta name="tags" content="docker"><meta name="tags" content="container"></head><body><div id="header" class="body"><div id="navigation"> | <a href="https://copyninja.in">Home</a> | | <a href="https://copyninja.in/about">About</a> | | <a href="https://copyninja.in/contact">Contact</a> | | <a href="https://copyninja.in/categories.html">Categories</a> | | <a href="https://copyninja.in/tags.html">Tags</a> | </div><h1><a href="https://copyninja.in/blog/docker-dev-environment.html">Docker container as Development Environment</a></h1></div><div id="content"><section id="content" class="body"><footer class="post-info"><p> Posted on Apr 14, 2018 By copyninja under devops </p></abbr></footer><div class="entry-content"><p>When you have a distributed team working on a project, you need to make sure that every one uses similar development environment. This is critical if you are working on embedded systems project. There are multiple possibility for this scenario.</p><ol class="arabic simple"><li>Use a common development server and provide every developer in your team an account in it.</li><li>Provide description to every one how to setup their development environment and trust them they will do so.</li><li>Use Docker to provide the developer with ready made environment and use build server (CI) for creating final deployment binaries.</li></ol><p>1st approach was most common approach used, but it has some drawbacks. Since its a shared system you should make sure not every one is able to install or modify system and hence have a single administrator so that no one accidentally breaks the development environment. Other problems include forced to use older OS due to specific requirements of compilers etc.</p><p>2nd approach makes you put your trust on your developer to get the correct development environment. Of course you need to trust your team, but every one is a human being and humans can make mistake.</p><div class="section" id="enter-docker"><h2>Enter Docker</h2><p><em>Dockerfile</em> is best way to document/setup development environment. A developer can read <em>Dockerfile</em> and understand what is being done to setup the environment and simply execute <cite>docker build</cite> command to generate his/her development environment, or better you build the image and publish it in either public registry and if that is not possible put it in a private registry, and ask developers to pull a image of development environment.</p><p>Don't be scared by <em>private registry</em>, setting one up is not a humongous task! Its just couple of docker commands and there is a pretty good <a class="reference external" href="https://docs.docker.com/registry/deploying/#run-a-local-registry">documentation</a> available to set one up.</p><p>While setting up a development environment you need to make sure last instruction in your <cite>Dockerfile</cite> is executing the shell of your choice. This is because when you start a container this last instruction is what actually is run by docker, and in our case we need to provide developer with a shell all build toolchain and libraries.</p><div class="highlight"><pre><span></span>...
<span class="k">CMD</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;/bin/bash&quot;</span><span class="p">]</span>
</pre></div><p>Now developer just needs to get/build the image, start the container and use it for their work!. To summarize below command is sufficient for developer to run a fresh environment.</p><div class="highlight"><pre><span></span>$<span class="w"> </span>docker<span class="w"> </span>build<span class="w"> </span>-t<span class="w"> </span>devenv<span class="w"> </span>.<span class="w"> </span><span class="c1"># If they are building it</span>

<span class="c1"># If they are pulling it from say private registry</span>
$<span class="w"> </span>docker<span class="w"> </span>pull<span class="w"> </span>private-registry-ip/path/to/devenv

$<span class="w"> </span>docker<span class="w"> </span>run<span class="w"> </span>-itd<span class="w"> </span>--name<span class="w"> </span>development<span class="w"> </span>devenv
$<span class="w"> </span>docker<span class="w"> </span>attach<span class="w"> </span>development
</pre></div><p>When container is started it will execute the shell and the next attach command will attach your shell's input/output to container. Now it can be used just like normal shell to build the application.</p><p>Another good thing which can be done is sharing the workspace with container so your container can just contain the toolchain and library that is needed and all version control, code editing and likewise can be done in the host machine. One thing that would be needed to make sure is your UID on host and UID of the user inside the container is same. This can be easily done by creating a separate user in the container with UID same as your UID on host system.</p></div><div class="section" id="advantages"><h2>Advantages</h2><p>Some advantages of using docker container include</p><ol class="arabic simple"><li>They are easy to setup and saves a lot of time to the team as a whole compared to traditional approaches.</li><li>Easy to throwaway and start fresh: If a developer thinks he did something wrong with container he can prune it and create a fresh one based on the development environment image. So this gives a lot of freedom to developer to experiment.</li><li>Uniformity: You will be sure that all your team will be using same evnironment.</li></ol><p>So you might ask what about other container technologies like systemd-nspawn or lxc etc. Of course they can also be used in the similar fashion, infact before experimenting with Docker I was a vivid user of <em>systemd-nspawn</em> container. You might have also seen my previous <a class="reference external" href="https://copyninja.info/tags/systemd-nspawn.html">blog posts</a> on <em>systemd-nspawn</em> too. Only reason I switched to Docker is its easy to setup unlike systemd-nspawn which needs so many tweaking and tuning of things besides it does not have a Dockerfile like approach which makes things more time consuming. So for me Docker won the war and I shifted to using Docker more.</p><p>This entire post was based on my experiment and experience with Docker. If you feel something can be done in a better way please feel free to write to me.</p></div></div><div id="footer"><p><italic>Tagged as: container, docker, </italic></p></section></div><hr><div id="footer"> Site Proudly powered by <a href="http://getpelican.com/">Pelican</a></div></body></html>