<!DOCTYPE html>
<html lang="en"><head><link href="https://fonts.googleapis.com/css?family=Cantarell" rel="stylesheet"/><title>SPAKE2 In Golang: Elliptic Curves Primer</title><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><meta content="width=device-width, initial-scale=1" name="viewport"/><link href="https://copyninja.in/feeds/all.atom.xml" rel="alternate" title="Random Ramblings Full Atom Feed" type="application/atom+xml"/><link href="https://copyninja.in/feeds/{slug}.atom.xml" rel="alternate" title="Random Ramblings Categories Atom Feed" type="application/atom+xml"/><link href="/theme/css/pygments.css" rel="stylesheet" type="text/css"/><link href="/theme/css/default.css" rel="stylesheet" type="text/css"/><meta content="go" name="tags"/><meta content="golang" name="tags"/><meta content="spake2" name="tags"/><meta content="cryptography" name="tags"/><meta content="ecc" name="tags"/></head><body><div class="body" id="header"><div id="navigation"> | <a href="https://copyninja.in">Home</a> | | <a href="https://copyninja.in/about">About</a> | | <a href="https://copyninja.in/contact">Contact</a> | | <a href="https://copyninja.in/categories.html">Categories</a> | | <a href="https://copyninja.in/tags.html">Tags</a> | </div><h1><a href="https://copyninja.in/blog/golang_spake2_2.html">SPAKE2 In Golang: Elliptic Curves Primer</a></h1></div><div id="content"><section class="body" id="content"><footer class="post-info"><p> Posted on Jul 28, 2018 By copyninja under development </p></footer><div class="entry-content"><blockquote> TLDR; this post is going to be too long and mostly theoretical. If you are wondering about where is Go in all these posts, please wait for few more posts before I can write about the actual implementation.</blockquote><p>In my <a class="reference external" href="https://copyninja.info/blog/golang_spake2_1.html">previous post</a> I talked about starting of my new adventure to write a cryptographic library and how I tried to brute force to solve problem without knowing basics. In this post I'll talk about my learning of <em>Elliptic Curves and their Groups</em>. This post is just my notes and I'm not trying to explain all basics or mathematics behind the Elliptic curves.</p><p>Ramakrishnan gave me a good article to start with Elliptic curves. Its a series of posts by <em>Andrea Corbellini</em>, which starts with <a class="reference external" href="http://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">Elliptic Curve Cryptography: A Gentle Introduction</a>. These posts gave me a great deal of understanding about elliptic curves and how elliptic curve cryptography works, and why its faster. If you want to learn about elliptic curve I highly recommend you to go through the series.</p><div class="section" id="elliptic-curves"><h2>Elliptic Curves</h2><p>Elliptic curves are set of points described by equation</p><div class="math"> \begin{equation*} y^2 = x^3 + ax + b \end{equation*} </div><p>where <cite>a</cite> and <cite>b</cite> are the coefficients which needs to satisfy <span class="math">\(4a^3 + 27b^2 \neq 0\)</span>. This form of equation is called <em>Weirstrass normal form of elliptic curves</em>.</p><p>Along with normal point there is also point on curve which is considered ideal point and is <em>point at infinity</em>; it is denoted by symbol 0. So considering point at infinity we can define elliptic curve as</p><div class="math"> \begin{equation*} \{(x,y) \in \mathbb R ^2 | y^2 = x^3 + ax + b, 4a^3 + 27b^2 \neq 0 \} \cup \{0\} \end{equation*} </div></div><div class="section" id="groups"><h2>Groups</h2><p>Before going to Elliptic curve groups we need to know what are groups. I now remembered my academics where I had studied about groups and number theory in general. That time never knew where exactly it was useful. And I should really say learning something without knowing its application is really difficult. Moving on to the groups,</p><p>A group in mathematics is basically a set for which there is a binary operation which is called as <em>"addition"</em> and idicated with + symbol. In order for set <span class="math">\(\mathbb G\)</span> the binary operation must be defined so that it has following properties.</p><ol class="arabic simple"><li><strong>closure</strong>: if <cite>a</cite> and <cite>b</cite> are members of of <span class="math">\(\mathbb G\)</span> then <span class="math">\(a + b\)</span> is also member of <span class="math">\(\mathbb G\)</span>.</li><li><strong>associativity</strong>: <span class="math">\((a + b) + c = a + (b + c);\)</span></li><li>there exists an <strong>identity element</strong> 0 such that <span class="math">\(a + 0 = 0 + a = a;\)</span></li><li>Every element has a inverse, that is for every <cite>a</cite> there exists <cite>b</cite> such that <span class="math">\(a + b = 0\)</span></li></ol><p>For a group to be Abelian there is a 5th rule.</p><ol class="arabic simple" start="5"><li><strong>commutativity</strong>: <span class="math">\(a + b = b + a\)</span></li></ol><p>If a group satisfies we get some additional property such that <strong>unique identity element</strong> and <strong>unique inverse element</strong> which is either directly or indirectly very important.</p><div class="section" id="elliptic-curve-groups"><h3>Elliptic Curve Groups</h3><p>Similar to number groups we defined above, its possible to have group over elliptic curves. Following are the property or rule for a Elliptic curve groups.</p><ol class="arabic simple"><li>Elements of the groups are point on elliptic curve;</li><li>the <strong>identity element</strong> is the point at infinity; yes the one we described above while defining elliptic curves.</li><li>the <strong>inverse</strong> of a point <span class="math">\(\mathrm R\)</span> is the one symmetric on <cite>x-axis</cite>. i.e. if point is <span class="math">\((x,y)\)</span> then inverse of the point is <span class="math">\((x, -y)\)</span></li><li><strong>adition</strong> is given by the rules: <strong>given three aligned, non-zero points,</strong><span class="math">\(\mathrm P,Q\)</span> <strong>and</strong> <span class="math">\(\mathrm R\)</span> <strong>their sum is</strong><span class="math">\(P + Q + R = 0\)</span>. This means the line through the 3 point passes through the point at infinity.</li><li>For addition we want 3 points to be aligned and does not require any specific order which means <span class="math">\(P + (Q + R) = Q + (P + R) = R + (P + Q) = ... = 0\)</span> that is <strong>our + operator is both associative and commutative</strong></li></ol><p>By point 5 we conclude that Elliptic curve groups are <em>Abelian</em>.</p></div><div class="section" id="algebraic-addition"><h3>Algebraic Addition</h3><p>Since we know <span class="math">\(P + Q + R = 0\)</span> we can say <span class="math">\(P + Q = -R\)</span>. This means we draw a line on elliptic curve which passes through point <cite>P</cite> and <cite>Q</cite> it intersects the curve at 3rd point <cite>R</cite>. Inverse of point <cite>R</cite> is <cite>-R</cite> and is the result of addition of 2 points <cite>P</cite> and <cite>Q</cite>. This is easy geometrically but for computers, we need to represent this with algebraic notation. This is where the <em>slope of line</em> comes to picture, another academic topic which I learnt without actually knowing its real world application.</p><p>So considering point <cite>P</cite> as <span class="math">\((x_P,y_P)\)</span> and <cite>Q</cite> as <span class="math">\((x_Q, y_Q)\)</span> we can calculate slope of line going from <cite>P</cite> to <cite>Q</cite> as follows</p><div class="math"> \begin{equation*} m = \frac{y_P - y_Q}{x_P - x_Q} \end{equation*} </div><p>And in a special case where <span class="math">\(P = Q\)</span> formula is slightly different</p><div class="math"> \begin{equation*} m = \frac{3x_P^2 + a}{2y_P} \end{equation*} </div><p>Intersection of this line with curve is point <cite>R</cite> <span class="math">\((x_R,y_R)\)</span> and point <span class="math">\(x_R\)</span> and <span class="math">\(y_R\)</span> are calculated using following formula.</p><div class="math"> \begin{equation*} x_R = m^2 - x_P - x_Q \end{equation*} </div><div class="math"> \begin{equation*} y_R = \begin{cases} y_P + m(x_R - x_P), &amp; \text{or} \\ y_Q + m(x_R - x_Q) \end{cases} \end{equation*} </div><p>I've not mentioned about special cases of elliptic curve additions which is explained in <a class="reference external" href="http://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">Andrea Corbellini</a> blog. Please refer for more mathematical oriented explanation.</p></div><div class="section" id="scalar-multiplication"><h3>Scalar Multiplication</h3><p>One more important operation we do with elliptic curve group is scalar multiplication. It allows you to calculate <span class="math">\(nP\)</span> where <cite>n</cite> is a natural number. Scalar multiplication can be implemented using addition as follows.</p><div class="math"> \begin{equation*} nP = \underbrace{P + P + \cdots + P}_{n\ \text{times}} \end{equation*} </div><p>This property is what makes elliptic curves attractive and faster than the normal integer groups where scalar multiplication is actually exponentiation operation.</p><p>If we see scalar multiplication formula above, we see that it requires <cite>n</cite> addition, which can be <span class="math">\(O(n)\)</span> operation or, if we consider <cite>n</cite> as <cite>k</cite> bit integer then algorithm will be <span class="math">\(O(2^k)`which looks highly inefficient when `n\)</span> is large prime number.</p><p>But there is another algorithm which is much faster for this purpose, its called <strong>double and add</strong> you can find <a class="reference external" href="https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication">wikipedia article on it</a>. First I did not understand this, but after a while of struggling, and trying to implement it myself it became pretty clear. It works with first taking binary representation of <cite>n</cite> <span class="math">\(n = n_0 + 2n_1 + 2^2_n2 + ...+2^kn_k\)</span> where <span class="math">\([n_0..n_k] \in \{0,1\}\)</span>. Below is pseudo code for the recursive version of algorithm.</p><pre class="code python literal-block">
<span class="k">def</span> <span class="nf">scalarmult</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span><span class="w">
</span>       <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span><span class="w">
</span>           <span class="k">return</span> <span class="n">P</span> <span class="c1"># identity element</span><span class="w">
</span>       <span class="k">if</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span><span class="w">
</span>           <span class="c1"># n is odd we add point</span><span class="w">
</span>           <span class="k">return</span> <span class="n">point_add</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">scalarmult</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="w">
</span>       <span class="k">else</span><span class="p">:</span><span class="w">
</span>           <span class="k">return</span> <span class="n">scalarmult</span><span class="p">(</span><span class="n">point_double</span><span class="p">(</span><span class="n">P</span><span class="p">),</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># we double point and multiply by n/2</span>
</pre><p>Let's consider an example to understand what is this algorithm doing. Lets say we want to caculate <cite>21P</cite>. First thing is we denote <cite>21</cite> as binary string <cite>10101</cite> now skipping all those 0's and consider only the 1's, so we will have <span class="math">\(2^4 + 2^2 + 2^0\)</span>. Now if we multiply P to this representation. So this algorithm calculates <cite>21P</cite> as <span class="math">\(16P + 4P + P\)</span>.</p><p>If we consider doubling and adding as constant operations i.e. <span class="math">\(O(1)\)</span> then this algorithm will be <span class="math">\(O(\log n)\)</span> (in above 21 can be calculated in 3 operations which is <span class="math">\(\log 21\)</span>) which is much better than earlier <span class="math">\(O(n)\)</span> algorithm.</p><p>Given <cite>n</cite> and <cite>P</cite> we can easily cacluate <span class="math">\(Q = nP\)</span> but given <cite>Q</cite> and <cite>P</cite> there is no <em>easy</em> way to find <cite>n</cite> especially when numbers are big. This is the <em>"hard"</em> problem or the <em>discrete logarithm problem</em> which makes cryptography work.</p></div></div><div class="section" id="conclusion"><h2>Conclusion</h2><p>So I learned now about Elliptic curves, its group and operations like scalar multiplication and addition. But this is not directly useful, we need to learn about <strong>Finite Fields</strong> and <strong>Elliptic Curve over Finite Field</strong> and many more concepts before we can go to actual implementation!. I thought of writing finite field as part of this post, but then I've already written a lot and there is no point in expanding this post more. So finite fields, cyclic groups will be part of next post.</p><p>As a closing note, if you are wondering why there is no mention of anything about Go, you need to wait a bit more for my actual implementation notes in Golang. I would like to write down entire learning process rather than directly jumping to implementation. So please bare with me :-).</p></div><script type="text/javascript">if(!document.getElementById('mathjaxscript_pelican_#%@#$@#')){var align="center",indent="0em",linebreak="false";if(false){align=(screen.width<768)?"left":align;indent=(screen.width<768)?"0em":indent;linebreak=(screen.width<768)?'true':linebreak;}
var mathjaxscript=document.createElement('script');mathjaxscript.id='mathjaxscript_pelican_#%@#$@#';mathjaxscript.type='text/javascript';mathjaxscript.src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';var configscript=document.createElement('script');configscript.type='text/x-mathjax-config';configscript[(window.opera?"innerHTML":"text")]="MathJax.Hub.Config({"+
"    config: ['MMLorHTML.js'],"+
"    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } },"+
"    jax: ['input/TeX','input/MathML','output/HTML-CSS'],"+
"    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],"+
"    displayAlign: '"+align+"',"+
"    displayIndent: '"+indent+"',"+
"    showMathMenu: true,"+
"    messageStyle: 'normal',"+
"    tex2jax: { "+
"        inlineMath: [ ['\\\\(','\\\\)'] ], "+
"        displayMath: [ ['$$','$$'] ],"+
"        processEscapes: true,"+
"        preview: 'TeX',"+
"    }, "+
"    'HTML-CSS': { "+
"        availableFonts: ['STIX', 'TeX'],"+
"        preferredFont: 'STIX',"+
"        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },"+
"        linebreaks: { automatic: "+linebreak+", width: '90% container' },"+
"    }, "+
"}); "+
"if ('default' !== 'default') {"+
"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {"+
"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;"+
"VARIANT['normal'].fonts.unshift('MathJax_default');"+
"VARIANT['bold'].fonts.unshift('MathJax_default-bold');"+
"VARIANT['italic'].fonts.unshift('MathJax_default-italic');"+
"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');"+
"});"+
"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {"+
"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;"+
"VARIANT['normal'].fonts.unshift('MathJax_default');"+
"VARIANT['bold'].fonts.unshift('MathJax_default-bold');"+
"VARIANT['italic'].fonts.unshift('MathJax_default-italic');"+
"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');"+
"});"+
"}";(document.body||document.getElementsByTagName('head')[0]).appendChild(configscript);(document.body||document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);}</script></div><div id="footer"><p><italic>Tagged as: cryptography, ecc, go, golang, spake2, </italic></p></div></section></div><hr/><div id="footer"> Site Proudly powered by <a href="http://getpelican.com/">Pelican</a></div></body></html>