<!DOCTYPE html><html lang="en"><head><link href="https://fonts.googleapis.com/css?family=Cantarell" rel="stylesheet"><title>Using WSME with Flask microframework</title><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="https://copyninja.in/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Random Ramblings Full Atom Feed"><link href="https://copyninja.in/feeds/{slug}.atom.xml" type="application/atom+xml" rel="alternate" title="Random Ramblings Categories Atom Feed"><link rel="stylesheet" type="text/css" href="/theme/css/pygments.css"><link rel="stylesheet" type="text/css" href="/theme/css/default.css"><meta name="tags" content="python"><meta name="tags" content="programming"><meta name="tags" content="wsme"><meta name="tags" content="rest"></head><body><div id="header" class="body"><div id="navigation"> | <a href="https://copyninja.in">Home</a> | | <a href="https://copyninja.in/about">About</a> | | <a href="https://copyninja.in/contact">Contact</a> | | <a href="https://copyninja.in/categories.html">Categories</a> | | <a href="https://copyninja.in/tags.html">Tags</a> | </div><h1><a href="https://copyninja.in/blog/wsme-with-flask.html">Using WSME with Flask microframework</a></h1></div><div id="content"><section id="content" class="body"><footer class="post-info"><p> Posted on Jun 03, 2014 By copyninja under development </p></abbr></footer><div class="entry-content"><p>After reading <a class="reference external" href="http://julien.danjou.info">Julien Danjou's</a> I found out WSME (Web Service Made Easy) a Python framework which allows us to easily create Web Services in Python. For <a class="reference external" href="http://silpa.org.in">SILPA</a> we needed a REST like interface and I thought of giving it try as WSME readily advertised the Flask integration, and this post was born when I read the documentation for Flask integration.</p><p>First of all Flask is a nice framework which will right way allow development of REST api for simple purposes, but my requirement was bit complicated where I had to expose function in a separate python modules through SILPA. I think detailed requirement can be part of another post, so let me explain how to use WSME with Flask app.</p><p>WSME integration with Flask is done via decorator function <cite>wsmeext.flask.signature</cite> which expects you to provide it with signature of function to expose. And <a class="reference external" href="http://wsme.readthedocs.org/en/latest/integrate.html#wsmeext.flask.signature">here</a> is its documentation, basically signature of <cite>signature</cite> function is</p><div class="highlight"><pre><span></span><span class="n">wsmeext</span><span class="o">.</span><span class="n">flask</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">return_type</span><span class="p">,</span> <span class="o">*</span><span class="n">arg_types</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
</pre></div><p>Yeah thats all docs have sadly.</p><p>So basically exposing is the only thing WSME handles for us here, routing and other stuffs need to be done by Flask itself. So lets consider a example, simple function to add as shown below.</p><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div><p>For providing REST like service, all you need below code.</p><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="kn">from</span> <span class="nn">wsmeext.flask</span> <span class="kn">import</span> <span class="n">signature</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/add&#39;</span><span class="p">)</span>
<span class="nd">@signature</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
       <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div><p>So first argument to <cite>signature</cite> is return type of function and rest arguments are the argument to function to be exposed. Now you can access the newly exposed service by visiting <em>http://localhost:5000/add</em> but don't forget to pass the arguments either via query string or through post. You can restrict methods of access via Flask's <cite>route</cite>.</p><p>So what's the big deal of not having docs right?.. Well fun part began when we use bit more complex return type like <em>dictionaries</em> or <em>lists</em> . Below is modified code I'm using to demonstrate problem I faced during using <cite>dict</cite> as return type.</p><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="kn">from</span> <span class="nn">wsmeext.flask</span> <span class="kn">import</span> <span class="n">signature</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/add&#39;</span><span class="p">)</span>
<span class="nd">@signature</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;result&quot;</span><span class="p">:</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">}</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div><p>Basically I'm returning a dictionary containing result now, for demonstration purpose. When I run the application <strong>boom</strong> python barked at me with following message.</p><div class="highlight"><pre><span></span><span class="gt">Traceback (most recent call last):</span>
<span class="x">File &quot;wsme_dummy.py&quot;, line 7, in &lt;module&gt;</span>
<span class="x"> @signature(dict, int, int)</span>
<span class="x">File &quot;c:\Users\invakam2\.virtualenvs\wsmetest\lib\site-packages\wsmeext\flask.py&quot;, line 48, in decorator</span>
<span class="x"> funcdef.resolve_types(wsme.types.registry)</span>
<span class="x">File &quot;c:\Users\invakam2\.virtualenvs\wsmetest\lib\site-packages\wsme\api.py&quot;, line 109, in resolve_types</span>
<span class="x"> self.return_type = registry.resolve_type(self.return_type)</span>
<span class="x">File &quot;c:\Users\invakam2\.virtualenvs\wsmetest\lib\site-packages\wsme\types.py&quot;, line 739, in resolve_type</span>
<span class="x"> type_ = self.register(type_)</span>
<span class="x">File &quot;c:\Users\invakam2\.virtualenvs\wsmetest\lib\site-packages\wsme\types.py&quot;, line 668, in register</span>
<span class="x"> class_._wsme_attributes = None</span>
<span class="x">TypeError: can&#39;t set attributes of built-in/extension type &#39;dict&#39;</span>
</pre></div><p>After going through code from files involved in above traces this is what I found</p><ol class="arabic simple"><li><cite>wsmeext.flask.signature</cite> inturn uses <cite>wsme.signature</cite> which is just alias of <cite>wsme.api.signature</cite>.</li><li>Link in documentation in sentence <em>See &#64;signature for parameter documentation</em> is broken and should actually link to <cite>wsme.signature</cite> in docs.</li><li><cite>wsme.signature</cite> actually calls <cite>resolve_type</cite> to check on types of return and arguments. This function checks if types are instance of <cite>dict</cite> or <cite>list</cite> in such cases it creates instances of <cite>wsme.type.DictType</cite> and <cite>wsme.type.ArrayType</cite> respectively with values from the argument.</li><li>When I just passed built-in type <cite>dict</cite> the control went to else part which just passed the type to <cite>wsme.type.Register.registry</cite> function which tries to set the attribute <cite>_wsme_attribute</cite> which actually raises <cite>TypeError</cite> as we can't set attribute for built-in types.</li></ol><p>So by inspecting code of <cite>wsme.type.Registry.resolve_type</cite> and <cite>wsme.type.Registry.register</cite> its clear that what signature expects when arguments or return type is dictionary/list is instance of dictionary/list with <cite>type</cite> of value in it. May be sentence is bit vague but I'm not sure how to put it more clearly, as an example in our case add function returns dictioanry with key as string and value as int, so return type argument for signature will be <cite>{str: int}</cite>. Similarly if you return array with int values it will be <cite>[int]</cite>.</p><p>With above understanding our add function now looks like below.</p><div class="highlight"><pre><span></span><span class="nd">@signature</span><span class="p">({</span><span class="nb">str</span><span class="p">:</span> <span class="nb">int</span><span class="p">},</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
   <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;result&#39;</span><span class="p">:</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">}</span>
</pre></div><p>and now code worked just fine!. What I couldn't figure out here is there is no way to have <cite>tuple</cite> as return value or argument, but I guess that is not big deal.</p><p>So immidiate task for me after finding this is fix the link in documentation to point to <cite>wsme.signature</cite> and probably put some note some where in documentation about above finding.</p></div><div id="footer"><p><italic>Tagged as: programming, python, rest, wsme, </italic></p></section></div><hr><div id="footer"> Site Proudly powered by <a href="http://getpelican.com/">Pelican</a></div></body></html>