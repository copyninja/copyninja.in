<!DOCTYPE html>
<html lang="en"><head><link href="https://fonts.googleapis.com/css?family=Cantarell" rel="stylesheet"/><title>SPAKE2 in Golang: ECDH, SPAKE2 and Curve Ed25519</title><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><meta content="width=device-width, initial-scale=1" name="viewport"/><link href="https://copyninja.in/feeds/all.atom.xml" rel="alternate" title="Random Ramblings Full Atom Feed" type="application/atom+xml"/><link href="https://copyninja.in/feeds/{slug}.atom.xml" rel="alternate" title="Random Ramblings Categories Atom Feed" type="application/atom+xml"/><link href="/theme/css/pygments.css" rel="stylesheet" type="text/css"/><link href="/theme/css/default.css" rel="stylesheet" type="text/css"/><meta content="go" name="tags"/><meta content="golang" name="tags"/><meta content="spake2" name="tags"/><meta content="cryptography" name="tags"/><meta content="ecc" name="tags"/></head><body><div class="body" id="header"><div id="navigation"> | <a href="https://copyninja.in">Home</a> | | <a href="https://copyninja.in/about">About</a> | | <a href="https://copyninja.in/contact">Contact</a> | | <a href="https://copyninja.in/categories.html">Categories</a> | | <a href="https://copyninja.in/tags.html">Tags</a> | </div><h1><a href="https://copyninja.in/blog/golang_spake2_4.html">SPAKE2 in Golang: ECDH, SPAKE2 and Curve Ed25519</a></h1></div><div id="content"><section class="body" id="content"><footer class="post-info"><p> Posted on Aug 28, 2018 By copyninja under development </p></footer><div class="entry-content"><p>In my <a class="reference external" href="https://copyninja.info/blog/golang_spake2_3.html">previous post</a> I talked about finite field and how it helps in <em>Elliptic Curve Cryptography</em>. In this post we will see briefly how Diffie-Hellmann key exchange varies with use of <em>Elliptic curve</em> groups, then we will see SPAKE2 original variant followed by Elliptic curve version and finally we will have a look at curve Ed25519 which is used as default group in <em>python-spake2</em> module.</p><div class="section" id="elliptic-curve-diffie-hellman-ecdh"><h2>Elliptic Curve Diffie-Hellman (ECDH)</h2><p>In the previous post we defined the domain parameter of elliptic curve cryptography as <span class="math">\((p, a, b, G, n, h)\)</span>. Now we will see how we use this in Diffie-Hellman Key exchange.</p><p>Diffie-Hellman key exchange is a way to securely exchange cryptographic key over public channel. Original Diffie-Hellman protocol used <strong>multiplicative group of integers modulo p</strong> where <cite>p</cite> is the a large prime and <cite>g</cite> a generator for subgroup (as we saw in earlier post). The protocol can be explained as follows</p><ol class="arabic simple"><li>Alice and Bob agrees on <cite>p</cite> and <cite>g</cite> belonging to group <cite>G</cite></li><li>Alice selects <cite>a</cite> belonging to <cite>G</cite> and calculates <span class="math">\(A = g^a \bmod{p}\)</span></li><li>Bob selects <cite>b</cite> belonging to <cite>G</cite> and calculates <span class="math">\(B = g^b \bmod{p}\)</span></li><li>Alice sends Bob <cite>A</cite></li><li>Bob sends Alice <cite>B</cite></li><li>Now Alice calculates <span class="math">\(s = B^a \bmod{p}\)</span></li><li>Now Bob calculates <span class="math">\(s = A^b \bmod{p}\)</span></li></ol><p>Mathematically <cite>s</cite> computed by both Alice and Bob are same and hence both share a shared secret now.</p><div class="math"> \begin{equation*} s = B^a \bmod{p} = g^{ba} \bmod{p} = A^b \bmod{p} = g^{ab} \bmod{p} \end{equation*} </div><p>Since group is Abelian <span class="math">\(g^{ba} \bmod{p} = g^{ab} \bmod{p}\)</span> and hence both side will come to same shared key.</p><p>Now in ECC,</p><ol class="arabic simple"><li>private key <span class="math">\(d\)</span> is a random integer choosen from <span class="math">\(\{1, \dots, n - 1\}\)</span> where <cite>n</cite> is the order of subgroup</li><li>public key is the point <span class="math">\(H = dG\)</span> where <cite>G</cite> is the base point of subgroup.</li></ol><p>With above now we can write Diffie-Hellman key exchange as</p><ol class="arabic simple"><li>Alice selects private key <span class="math">\(d_A\)</span> and public key <span class="math">\(H_A = d_AG\)</span> and sends it to Bob</li><li>Bob selects private key <span class="math">\(d_B\)</span> and public key <span class="math">\(H_B = d_BG\)</span> and sends it to Alice</li><li>Alice calculates <span class="math">\(S = d_AH_B\)</span> and Bob calculates <span class="math">\(S = d_BH_A\)</span> which if you see carefully is one and same and Alice and Bob now share a secret key!.</li></ol><div class="math"> \begin{equation*} S = d_A H_B = d_A (d_B G) = d_B (d_A G) = d_B H_A \end{equation*} </div><p>In both cases observer only sees the public key and will not be able to find discrete logarithm (hard problem), given the numbers are large prime.</p><p>Advantage of ECDH is its faster as its replacing the costly exponentiation operation with <em>scalar multiplication</em> without reducing hardness of the problem.</p></div><div class="section" id="spake2-protocol"><h2>SPAKE2 Protocol</h2><p>Now that we understood Diffie-Hellman exchange and saw how to apply Elliptic curve in Diffie-Hellman exchange, lets see what is SPAKE2 protocol. This paper by <a class="reference external" href="https://www.di.ens.fr/~pointche/Documents/Papers/2005_rsa.pdf">Abdalla and Pointcheval</a> gives full explanation of SPAKE2 and proof of its security. I highly recommend reading the paper as I can only summarize my understadning here.</p><p>SPAKE2 is a variation of Diffie-Hellman problem we described above. Domain parameters for SPAKE2 are <span class="math">\((G, g, p, M, N, H)\)</span></p><ul class="simple"><li><cite>G</cite> is the group</li><li><cite>g</cite> is the generator for group</li><li><cite>p</cite> is the big prime which is order of group</li><li><span class="math">\(M, N \in G\)</span> and are selected by Alice and Bob respectively</li><li><cite>H</cite> is the hash function used to derive final shared key.</li></ul><p>Along with this SPAKE2 both side will have common password <span class="math">\(pw \in Z_p\)</span>. Protocol is defined as follows</p><ol class="arabic simple"><li>Alice selects a random scalar <span class="math">\(x \xleftarrow{R} Z_p\)</span> and calculates <span class="math">\(X \leftarrow g^x\)</span>.</li><li>Alice then computes <span class="math">\(X^* \leftarrow X \cdot M^{pw}\)</span></li><li>Bob selects a random scalar <span class="math">\(y \xleftarrow{R} Z_p\)</span> and calculates <span class="math">\(Y \leftarrow g^y\)</span>.</li><li>Bob then computes <span class="math">\(Y^* \leftarrow Y \cdot N^{pw}\)</span>.</li><li><span class="math">\(X^*, Y^*\)</span> are called pake messages and are sent to other side. i.e. Alice sends <span class="math">\(X^*\)</span> to Bob and Bob sends <span class="math">\(Y^*\)</span> to Alice.</li><li>Alice computes <span class="math">\(K_A \leftarrow (Y*/N^{pw})^x\)</span> and Bob computes <span class="math">\(K_B \leftarrow (X^*/M^{pw})^y\)</span></li><li>Shared Key is calculated by Alice as <span class="math">\(SK_A \leftarrow H(A,B,X^*,Y^*,pw,K_A)\)</span> and Bob computes <span class="math">\(SK_B \leftarrow H(A,B,X^*,Y^*, pw, K_B)\)</span></li></ol><p><span class="math">\(SK_A = SK_B\)</span> because mathematically value <span class="math">\(K_A = K_B\)</span> (you can expand <span class="math">\(X^*\)</span> and <span class="math">\(Y^*\)</span> in step <cite>6</cite> aboveand see that they are really same).</p><p>In step <cite>7</cite> we calculate Hash of transcript, where <cite>A</cite> and <cite>B</cite> are identities of Alice and Bob. and rest is calculated during protocol execution.</p><p>One thing to note here is paper does not define what are identities or which hash function is used. This allows some creativity from implementer side to choose things. For <em>python-spake2</em> interoperability <em>Brian</em> has written a <a class="reference external" href="http://www.lothar.com/blog/57-SPAKE2-Interoperability/">detailed blog post</a> describing decision he has taken for all these points which are not defined in original paper.</p></div><div class="section" id="curve-ed25519-group"><h2>Curve Ed25519 Group</h2><p>Now that we have seen the SPAKE2 protocol, we will next see the use of Elliptic Curve groups in it and see how it varies.</p><p>SPAKE2 uses <em>Abelian Group</em> with large number of "elements". We know that Elliptic curve groups are Abelian groups, so we can fit them in SPAKE2. <a class="reference external" href="http://lothar.com/blog/">Brian Warner</a> has choosen elliptic curve group <em>Ed25519</em> (some times also referred as X25519) as default group in <em>python-spake2</em> implementation. This is the same group which is used in <em>Ed25519 signature scheme</em>. The difference between multiplicative integer group modulo p and elliptic curve group is that, element in integer group is just a number but in elliptic curve group its a point. (represented by 2 co-ordinates).</p><p>Curve Ed25519 which is actually called Edwards25519 is a <em>twisted Edwards curve</em>, defined in affine form as <span class="math">\(ax^2 + y^2 = 1 + dx^2y^2\)</span> where <span class="math">\(d \in k\{0,1\}\)</span>.</p><ul class="simple"><li><span class="math">\(q = 2^{255} - 19\)</span> is the order of curve groups</li><li><span class="math">\(l = 2^{252} + 27742317777372353535851937790883648493\)</span> is the order of curve subgroup.</li><li><span class="math">\(a = -1\)</span></li><li><span class="math">\(d = \frac{-121665}{121666}\)</span></li><li>Base point <span class="math">\(B\)</span> is unique and has y-co-ordinate <cite>:math:4/5</cite> and x co-ordinate is positive.</li></ul><p>Curve itself is given as <span class="math">\(E/\mathbb F_q\)</span></p><div class="math"> \begin{equation*} -x^2 + y^2 = 1 - \frac{121665}{121666} x^2y^2 \end{equation*} </div><p>This curve is birationally equivalaent to the Montgomery curve known as <em>Curve25519</em>. If you are wondering what <em>25519</em> is?, well its in the order of group i.e. <span class="math">\(2^{255} - 19\)</span>.</p><p>Till now we were working with elliptic curves with affine co-ordinates, i.e. each point is represented as <span class="math">\((x,y)\)</span>. But for fast operation twisted edwards curve introduces new type of co-ordinates called <em>Extended Co-ordinates</em> where <em>x, y</em> is represented as <em>X,Y,T and Z</em>, and affine co-ordinates are represented using the extended co-ordinates as follows</p><div class="math"> \begin{align*} x = X/Z \\ y = Y/Z \\ x*y = T/Z \\ \end{align*} </div><p>Initial base point is converted to extended co-ordinate using <cite>Z</cite> as 1. In all above case the operations are <span class="math">\(mod q\)</span>. Additionally all division operations are actually multiplication with inverse of element.</p><p>We also noted above, Base point represented using only y co-ordinate. This is because x co-ordinate can be recovered from y, using twisted edwards curve equation we defined above. In most of libraries you will see that this compressed notation of representing a point as just <cite>y</cite> co-ordinate is used. (Its called <em>CompressedEdwardsY</em> in Rust's <em>curve25519-dalek</em> crate.)</p><p>In all above case the operations are <span class="math">\(mod q\)</span>. Additionally all division operations are actually multiplication with inverse of element.Inverse of a element is calculated as point raised to power <cite>q-2</cite> modulo <cite>q</cite>. I could not find the technical/mathematical reason behind this. If some one knows please let me know. So the inverse operation can be mathematically defined as follows.</p><div class="math"> \begin{equation*} x^{-1} = x^{q - 2} \bmod{q} \end{equation*} </div><p>The addition and doubling operations are as per algorithms defined in <a class="reference external" href="http://www.hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html">hyperelliptic.org post</a>. We have seen scalar multiplication in <a class="reference external" href="https://copyninja.info/blog/golang_spake2_2.html">second post of this series</a>, which depends on addition and doubling operation.</p><div class="section" id="spake2-using-ed25519-group"><h3>SPAKE2 using Ed25519 group</h3><p>Unlike normal elliptic curve here the domain parameters are slightly different. Ed25519 domain parameters are defined as <span class="math">\((q, d, B, l)\)</span> where <cite>q</cite> gives the order of elliptic curve group and <cite>l</cite> is the order of subgroup. <cite>B</cite> is the base point of the group.</p><p>Now lets rewrite original SPAKE2 protocol using elliptic curve groups</p><ol class="arabic simple"><li>Alice selects a random scalar <span class="math">\(x \xleftarrow{R} E/\mathbb F_q\)</span> and calculates <span class="math">\(X \leftarrow B \cdot x\)</span> and computes <span class="math">\(X^* \leftarrow X + M \cdot pw\)</span>. Alice sends <span class="math">\(X^*\)</span> to Bob.</li><li>Bob selects random scalar <span class="math">\(y \xleftarrow{R} E/\mathbb F_q\)</span> and calculates <span class="math">\(Y \leftarrow B \cdot y\)</span> and computes <span class="math">\(Y^* \leftarrow Y + N \cdot pw\)</span>. Bob sends <span class="math">\(Y^*\)</span> to Alice.</li><li>Alice now calculates <span class="math">\(K_A \leftarrow (Y^* - N \cdot pw) \cdot x\)</span></li><li>Bob now calculates <span class="math">\(K_B \leftarrow (X^* - M \cdot pw) \cdot y\)</span></li><li>Shared key is calculated by Alice <span class="math">\(SK_A \leftarrow H(A, B, X^*, Y^*, pw, K_A)\)</span> and by Bob <span class="math">\(SK_B \leftarrow H(A,B, X^*, Y^*, pw, K_B)\)</span></li></ol><p>In 3 and 4 if you expand <span class="math">\(X^*\)</span> and <span class="math">\(Y^*\)</span> you will see that <span class="math">\(K_A = K_B\)</span>. And given password used by both sides are same we will arrive at same shared key.</p><p>As you see above protocol for SPAKE2 remains same only things what changed from earlier is operations, exponentiation is changed to multiplication and division to substraction. Since we do not explicitly define substraction what we do is negate the password and do addition instead.</p></div></div><div class="section" id="conclusion"><h2>Conclusion</h2><p>So we now have seen all the basics needed to start writing the actual Go code to implement SPAKE2 library. It was bit long I know but if you know the basics writing code is a cake walk!. (quoting from Ramakrishnan). So in the next post I will start writing implementation notes.</p></div><script type="text/javascript">if(!document.getElementById('mathjaxscript_pelican_#%@#$@#')){var align="center",indent="0em",linebreak="false";if(false){align=(screen.width<768)?"left":align;indent=(screen.width<768)?"0em":indent;linebreak=(screen.width<768)?'true':linebreak;}
var mathjaxscript=document.createElement('script');mathjaxscript.id='mathjaxscript_pelican_#%@#$@#';mathjaxscript.type='text/javascript';mathjaxscript.src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';var configscript=document.createElement('script');configscript.type='text/x-mathjax-config';configscript[(window.opera?"innerHTML":"text")]="MathJax.Hub.Config({"+
"    config: ['MMLorHTML.js'],"+
"    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } },"+
"    jax: ['input/TeX','input/MathML','output/HTML-CSS'],"+
"    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],"+
"    displayAlign: '"+align+"',"+
"    displayIndent: '"+indent+"',"+
"    showMathMenu: true,"+
"    messageStyle: 'normal',"+
"    tex2jax: { "+
"        inlineMath: [ ['\\\\(','\\\\)'] ], "+
"        displayMath: [ ['$$','$$'] ],"+
"        processEscapes: true,"+
"        preview: 'TeX',"+
"    }, "+
"    'HTML-CSS': { "+
"        availableFonts: ['STIX', 'TeX'],"+
"        preferredFont: 'STIX',"+
"        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },"+
"        linebreaks: { automatic: "+linebreak+", width: '90% container' },"+
"    }, "+
"}); "+
"if ('default' !== 'default') {"+
"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {"+
"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;"+
"VARIANT['normal'].fonts.unshift('MathJax_default');"+
"VARIANT['bold'].fonts.unshift('MathJax_default-bold');"+
"VARIANT['italic'].fonts.unshift('MathJax_default-italic');"+
"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');"+
"});"+
"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {"+
"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;"+
"VARIANT['normal'].fonts.unshift('MathJax_default');"+
"VARIANT['bold'].fonts.unshift('MathJax_default-bold');"+
"VARIANT['italic'].fonts.unshift('MathJax_default-italic');"+
"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');"+
"});"+
"}";(document.body||document.getElementsByTagName('head')[0]).appendChild(configscript);(document.body||document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);}</script></div><div id="footer"><p><italic>Tagged as: cryptography, ecc, go, golang, spake2, </italic></p></div></section></div><hr/><div id="footer"> Site Proudly powered by <a href="http://getpelican.com/">Pelican</a></div></body></html>